<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>ESP32 PLC Editor</title>
<style>
body{margin:0;height:100vh;display:flex;flex-direction:column;font-family:Inter, Arial, sans-serif;overflow:hidden;background:#f5f7fa;}
#topbar{height:52px;background:#0f1724;color:#fff;display:flex;align-items:center;padding:0 16px;box-sizing:border-box;gap:18px;position:relative;z-index:50;}
#topbar .title{font-size:15px;font-weight:600;opacity:.9;margin-right:auto;}
.toolbar-status{display:flex;gap:8px}
.status-btn{border:none;padding:6px 12px;border-radius:6px;font-size:13px;font-weight:600;cursor:pointer;opacity:.95;transition:.12s;box-shadow:none;color:#fff;display:flex;align-items:center;gap:8px;min-width:84px;justify-content:center}
/* Inactive (off) should be dark/muted */
.status-btn{background:#0b1220;color:#8b97a6;opacity:0.85;filter:grayscale(40%);box-shadow:none}
/* Active colors override */
.status-btn.run.active{background:#059669;color:#fff;filter:none;opacity:1}
.status-btn.stop.active{background:#dc2626;color:#fff;filter:none;opacity:1}
.status-btn.error.active{background:#f97316;color:#fff;filter:none;opacity:1}
.status-btn.reset.active{background:#2563eb;color:#fff;filter:none;opacity:1}
.status-btn.deploying{background:#d97706;color:#fff}

/* debug button style */
.status-btn.debug{background:#334155;color:#fff}
.status-btn[disabled]{cursor:default;opacity:0.6;filter:grayscale(40%);pointer-events:none}

/* deploy modified indicator (yellow) */
#deploy-btn.modified { background:#d97706 !important; color:#fff !important; box-shadow:0 6px 18px rgba(217,119,6,.18); transform:translateY(-1px); }

/* rest */
.actions{display:flex;gap:8px;margin-left:auto}
#deploy-btn,#menu-btn,.undo-btn,.redo-btn{border:none;padding:6px 10px;border-radius:6px;font-size:13px;font-weight:600;cursor:pointer;opacity:.95;background:#111827;color:#fff;}
/* Remove spinner buttons from number inputs */
input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
input[type="number"] {
  -moz-appearance: textfield;
}
#menu-popup{position:absolute;top:56px;right:12px;background:#0b1220;color:#e6eef8;border-radius:8px;box-shadow:0 8px 24px rgba(2,6,23,.6);display:none;min-width:220px;z-index:1000;}
#menu-popup>div{padding:10px 14px;font-size:13px;cursor:pointer;position:relative;}
#menu-popup>div:hover{background:#071127}
#settings-submenu{position:absolute;right:100%;top:0;background:#0b1220;border-radius:8px;box-shadow:0 8px 24px rgba(2,6,23,.6);min-width:200px;display:none;padding:8px 10px;}
#menu-settings:hover #settings-submenu{display:block;}
#settings-submenu label{display:flex;align-items:center;cursor:pointer;padding:6px 0;font-size:13px;}
#settings-submenu input[type="checkbox"]{margin-right:8px;cursor:pointer;}
#main{flex:1;display:flex;overflow:auto}
#palette { width: 140px; background: #232f41; color: #e5ecfa; padding: 12px; border-right: 1px solid rgba(255,255,255,0.04); box-sizing: border-box; overflow-y: auto; max-height: 100vh; border-radius: 0; box-shadow: 0 8px 24px rgba(2,6,23,0.32); }
#palette::-webkit-scrollbar { width: 8px; }
#palette::-webkit-scrollbar-track { background: #232f41; }
#palette::-webkit-scrollbar-thumb { background: #40506b; border-radius: 6px; }
#palette::-webkit-scrollbar-thumb:hover { background: #5a6c7d; }
.palette-category { margin-bottom: 12px; }
.palette-category-header { background: #40506b; padding: 6px 10px; cursor: pointer; font-weight: 700; border-radius: 8px; margin-bottom: 6px; color: #ffffff; font-size:13px; }
.palette-category-content { padding-left: 10px; }
.palette-search { background: transparent; padding: 6px; border-radius: 10px; margin-bottom: 12px; }
.palette-search input { width: 92%; padding: 8px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.06); background: #232f41; font-size: 13px; color: #fafcff; }
.palette-search input::placeholder { color: #8b97a6; }
.palette-item { background: #2b3a51; margin-bottom: 10px; padding: 10px; border-radius: 12px; text-align: center; cursor: grab; user-select: none; border: 1px solid rgba(255,255,255,0.06); font-weight: 700; color: #ffffff; transition: background .18s, transform .08s, box-shadow .18s; box-shadow: 0 6px 18px rgba(3,10,24,0.12); }
.palette-item:active{ transform: translateY(1px); }
.palette-item:hover { background: #354157; box-shadow: 0 10px 28px rgba(3,10,24,0.18); }
#flow-wrapper{flex:1;overflow:auto;background:linear-gradient(180deg,#edf2f7,#fbfdff);display:flex;align-items:flex-start;justify-content:flex-start;padding:0;width:100%;height:100%;min-height:calc(100vh - 52px)}
#viewport{width:100%;height:100%;min-width:3000px;min-height:2000px;position:relative;background:linear-gradient(#e9eef3 1px,transparent 1px),linear-gradient(90deg,#e9eef3 1px,transparent 1px);background-size:40px 40px;transform-origin:0 0;border-radius:10px;box-shadow:inset 0 1px 0 rgba(255,255,255,.6); will-change: transform;border:1px solid rgba(0,0,0,0.04);}
/* grid hidden class */
#viewport.grid-off{background-image:none;}
svg{position:absolute;width:100%;height:100%}
.node{position:absolute;width:150px;background:#fff;border:1px solid rgba(2,6,23,.06);border-radius:12px;cursor:move;user-select:none;box-shadow:0 6px 18px rgba(3,10,24,.06); transition: border-color .18s, background-color .18s;}
/* Selection (orange) - slightly thicker than default (2px) */
.node.selected{border-color:#fb923c;box-shadow:0 10px 28px rgba(251,146,60,.12); border-width:2px;}
.node.multi-selected{border-color:#fb923c; border-width:2px}
/* Active-high (green) when PLC is RUN and address=true; slightly thicker and stronger box-shadow.
   Placed after .selected so active state can override selection visually.
*/
.node.active-high{background:#ecfdf5;border-color:#34d399; border-width:2px; box-shadow:0 10px 28px rgba(52,211,153,.08); animation: activeBlink 2s ease-in-out infinite;}
.node.active-high .addr, .node.active-high .tag { color: #064e3b; }
/* When both selected and active-high, selection (orange) takes precedence */
.node.selected.active-high{border-color:#fb923c; box-shadow:0 10px 28px rgba(251,146,60,.12);}
/* Validation error (red) - unanchored nodes */
.node.validation-error{border-color:#ef4444 !important;border-width:3px;background:#fee2e2 !important;box-shadow:0 10px 28px rgba(239,68,68,.12);}
/* Edge blink effect (rising/falling) - 1s */
.node.edge-blink { animation: edgeBlink 1s ease; border-color:#2563eb !important; box-shadow:0 12px 30px rgba(37,99,235,.12); }
@keyframes edgeBlink {
  0% { box-shadow: 0 0 0 0 rgba(37,99,235,0.32); }
  40% { box-shadow: 0 0 18px 6px rgba(37,99,235,0.14); }
  100% { box-shadow: 0 0 0 0 rgba(37,99,235,0); }
}
@keyframes activeBlink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}
#selection-box{position:absolute;border:2px dashed #fb923c;background:rgba(251,146,60,.06);pointer-events:none;display:none;border-radius:8px}
#paste-preview{position:absolute;pointer-events:none;opacity:0.6;display:none}
#paste-preview .node{border-color:#fb923c;box-shadow:0 0 0 2px rgba(251,146,60,.08)}
.symbol{text-align:center;font-size:18px;padding:8px 0;background:linear-gradient(#f8fafc,#fff);border-bottom:1px solid #f1f5f9;border-top-left-radius:10px;border-top-right-radius:10px;font-weight:700;color:#0b1220}
.addr,.tag,.setpoint,.instruction,.args{font-size:13px;padding:6px;text-align:center;cursor:text;color:#0b1220}
.word-val{font-size:12px;padding:4px 6px;text-align:center;color:#065f46;background:rgba(6,95,70,0.06);border-radius:6px;margin:6px auto 8px;display:none}

/* value badge shown above instruction nodes */
.value-badge{position:absolute;top:-12px;left:50%;transform:translateX(-50%);background:#ffffff;border:1px solid rgba(2,6,23,0.06);padding:4px 8px;border-radius:8px;font-size:12px;color:#064e3b;box-shadow:0 6px 18px rgba(3,10,24,.06);display:none;white-space:nowrap}
.placeholder{color:#9aa3b2;font-style:italic}
.port{width:14px;height:14px;background:#cbd5e1;border-radius:4px;position:absolute;top:50%;transform:translateY(-50%);transition:.12s}
.port:hover{background:#fb923c}
.port.in{left:-7px}
.port.out{right:-7px}
.port.invalid{background:#ff4d4f !important; box-shadow:0 0 8px rgba(255,77,79,.35)}
.link{stroke:#9aa3b2;stroke-width:3;fill:none; transition: stroke .14s, stroke-width .14s}
.link.selected{stroke:#fb923c;stroke-width:4}
.link-hit{stroke:transparent;stroke-width:20;fill:none;pointer-events:stroke}
#zoom-controls{position:fixed;right:20px;bottom:20px;Display:flex;flex-direction:column;gap:8px}
#zoom-controls button{width:40px;height:40px;border:none;border-radius:8px;font-size:16px;background:#40506b;color:#fff;cursor:pointer;box-shadow:0 8px 18px rgba(3,10,24,.06)}
#mini-palette{
  position:fixed;
  display:none;
  background:#fff;
  padding:12px;
  border-radius:10px;
  box-shadow:0 8px 24px rgba(2,6,23,.18);
  z-index:9999;
  border:1px solid #e3e3e3;
  min-width:120px;
  text-align:center;
  transition:opacity .16s;
}

/* Sidebar (console) - palette-style */
#sidebar {
  position:fixed;
  top:52px;
  right:-320px; /* hidden by default */
  width:320px;
  height:calc(100% - 52px);
  background:#232f41;
  color:#e5ecfa;
  box-shadow: -12px 0 24px rgba(2,6,23,.6);
  border-left:1px solid rgba(255,255,255,0.04);
  transition: right .28s ease;
  z-index:60;
  display:flex;
  flex-direction:column;
  padding:12px;
  box-sizing:border-box;
  border-radius:0;
}
#sidebar.open { right:0; }
#sidebar .header { display:flex;align-items:center;gap:8px;padding:8px 4px;border-bottom:1px solid rgba(255,255,255,0.03); }
#sidebar .header h3 { margin:0;font-size:18px;display:flex;align-items:center;gap:8px;background:#232f41;padding:6px 10px;border-radius:8px;color:#fff;font-weight:700 }
#sidebar .controls { margin-left:auto; display:flex; gap:8px; align-items:center; }
#sidebar .log-filters { display:flex; gap:8px; margin-left:0px; align-items:center; }
#sidebar .log-filters label { font-size:12px; display:flex; align-items:center; gap:6px; cursor:pointer; color:#cfe6ff; }
#sidebar .log-list { overflow:auto; padding:8px; flex:1; font-size:13px; background:transparent; }
#sidebar .log-list::-webkit-scrollbar { width: 8px; }
#sidebar .log-list::-webkit-scrollbar-track { background: #232f41; }
#sidebar .log-list::-webkit-scrollbar-thumb { background: #40506b; border-radius: 6px; }
#sidebar .log-list::-webkit-scrollbar-thumb:hover { background: #5a6c7d; }
#sidebar .tabs { display:flex; gap:10px; font-size:14px; border-bottom:1px solid rgba(255,255,255,0.06); margin-bottom:10px; }
#sidebar .tab { cursor:pointer; padding:6px 10px; border-radius:6px; transition:background .2s; color:#cfe6ff; background:transparent; }
#sidebar .tab.active { background:#40506b; color:#fff; box-shadow:0 6px 18px rgba(3,10,24,.12); }
#sidebar .memory-list { overflow:auto; padding:8px; flex:1; font-size:13px; max-height: calc(100vh - 200px); }
#sidebar .memory-list::-webkit-scrollbar { width: 8px; }
#sidebar .memory-list::-webkit-scrollbar-track { background: #232f41; }
#sidebar .memory-list::-webkit-scrollbar-thumb { background: #40506b; border-radius: 4px; }
#sidebar .memory-list::-webkit-scrollbar-thumb:hover { background: #5a6c7d; }
#wifi-networks::-webkit-scrollbar { width: 8px; }
#wifi-networks::-webkit-scrollbar-track { background: #232f41; }
#wifi-networks::-webkit-scrollbar-thumb { background: #40506b; border-radius: 4px; }
#wifi-networks::-webkit-scrollbar-thumb:hover { background: #5a6c7d; }
 .memory-item { padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.05); display:flex; justify-content:space-between; cursor: pointer; transition: background-color 0.2s; }
 .memory-item:hover:not(:has(strong)) { background-color: rgba(255,255,255,0.04); border-radius: 4px; }
 .memory-item .addr { color:#9aa3b2; }
 .memory-item .value { color:#34d399; }
 .log-entry { padding:12px;border-radius:12px;margin-bottom:10px;background:#2b3a51;border:1px solid rgba(255,255,255,0.06);box-shadow:0 6px 18px rgba(3,10,24,.12);color:#e5ecfa }
 .log-entry .ts { font-size:11px;color:#8b97a6;margin-bottom:6px; }
 .log-entry .msg { white-space:pre-wrap; color:#eaf6ff; }

/* small badge for unread errors (removed per request) */
/* .error-indicator { ... } */

.tab-content { flex:1; display:flex; flex-direction:column; }

@media (max-width:900px){
  #palette{display:none}
  #viewport{width:2000px;height:1600px}
}
</style>
</head>
<body>

<div id="topbar">
  <div class="title">ESP32_WEB_PLC</div>
  <div class="toolbar-status">
    <!-- RUN/STOP/ERROR/RESET, ERROR has no button action and no red dot -->
    <button class="status-btn run" data-mode="RUN">RUN</button>
    <button class="status-btn stop active" data-mode="STOP">STOP</button>
    <button class="status-btn error" data-mode="ERROR" disabled>ERROR</button>
    <button class="status-btn reset" data-mode="RESET">RESET</button>
    <!-- DEBUG button added next to RESET -->
    <button class="status-btn debug" data-mode="DEBUG">DEBUG</button>
  </div>
  <div class="actions">
    <button class="undo-btn">⮌</button>
    <button class="redo-btn">⮎</button> 
    <button id="deploy-btn">Deploy</button>
    <button id="menu-btn">☰</button>
  </div>
</div>

<div id="menu-popup">
  <div id="menu-import">Import (From ESP32)</div>
  <div id="menu-import-file">Import (From File)</div>
  <div id="menu-export">Export (To File)</div>
  <div id="menu-verify">Verify (Compare)</div>
  <div id="menu-settings">
    Settings
    <div id="settings-submenu">
      <label>
        Grid
        <input type="checkbox" id="grid-snap-checkbox" checked>
      </label>
    </div>
  </div>
  <div id="menu-about">About</div>
</div>

<div id="main">
  <div id="palette">
    <div class="palette-search"><input id="search" placeholder="Search node" autocomplete="off"></div>
    <div class="palette-item" draggable="true" data-type="open">Open</div>
    <div class="palette-item" draggable="true" data-type="close">Close</div>
    <div class="palette-item" draggable="true" data-type="rising">Rising</div>
    <div class="palette-item" draggable="true" data-type="falling">Falling</div>
    <div class="palette-item" draggable="true" data-type="invert">Invert</div>
    <div class="palette-item" draggable="true" data-type="coil">Coil</div>
    <div class="palette-item" draggable="true" data-type="set">Set</div>
    <div class="palette-item" draggable="true" data-type="reset">Reset</div>
    <div class="palette-item" draggable="true" data-type="instruction">INS</div>
  </div>
  <div id="flow-wrapper"><div id="viewport"><svg id="lines"></svg><div id="selection-box"></div><div id="paste-preview"></div></div></div>
</div>

<!-- Sidebar for console logs -->
<div id="sidebar" aria-hidden="true">
  <div class="header">
    <div style="display:flex;align-items:center;width:100%;">
    <h3>Debug Console</h3>
    <div class="controls" style="margin-left:auto;">
      <button id="close-sidebar" title="Close" style="background:#40506b;border:none;color:#fff;padding:6px;border-radius:6px;cursor:pointer">Close</button>
    </div>
  </div>
  </div>

  <!-- Tabs (Console / Memory / I/O / WiFi) -->
  <div class="tabs" id="sidebar-tabs">
    <div class="tab active" data-tab="console">Console</div>
    <div class="tab" data-tab="memory">Memory</div>
    <div class="tab" data-tab="io">I/O</div>
    <div class="tab" data-tab="wifi">WiFi</div>
  </div>

  <div class="tab-content" style="padding:8px 0;flex:1;display:flex;flex-direction:column;">
    <!-- Console Controls + Filters (2 rows) -->
    <div id="console-controls" style="display:flex;flex-direction:column;gap:4px;padding:8px 4px;border-bottom:1px solid rgba(255,255,255,0.03);">
      <!-- Row 1: Error, Debug, Scroll -->
      <div style="display:flex;gap:12px;align-items:center;">
        <label style="font-size:12px;display:flex;align-items:center;gap:6px;cursor:pointer;color:#cfe6ff;"><input type="checkbox" id="filter-error" checked> Error</label>
        <label style="font-size:12px;display:flex;align-items:center;gap:6px;cursor:pointer;color:#cfe6ff;"><input type="checkbox" id="filter-debug" checked> Debug</label>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center;">
          <button id="auto-scroll-btn" title="Toggle auto scroll" style="background:#2b3a51;border:none;color:#fff;padding:6px;border-radius:6px;cursor:pointer;font-size:12px;">Scroll</button>
        </div>
      </div>
      <!-- Row 2: System, WebSocket, Clear -->
      <div style="display:flex;gap:12px;align-items:center;">
        <label style="font-size:12px;display:flex;align-items:center;gap:6px;cursor:pointer;color:#cfe6ff;"><input type="checkbox" id="filter-system" checked> System</label>
        <label style="font-size:12px;display:flex;align-items:center;gap:6px;cursor:pointer;color:#cfe6ff;"><input type="checkbox" id="filter-ws" checked> WebSocket</label>
        <div style="margin-left:auto;display:flex;gap:8px;align-items:center;">
          <button id="clear-errors" title="Clear logs" style="background:#2b3a51;border:none;color:#fff;padding:6px;border-radius:6px;cursor:pointer;font-size:12px;">Clear</button>
        </div>
      </div>
    </div>

    <!-- Console log list (default visible) -->
    <div class="log-list" id="error-list" style="display:block;"></div>

    <!-- Memory list (hidden initially) -->
    <div class="memory-list" id="memory-list" style="display:none;"></div>

    <!-- I/O list (hidden initially) -->
    <div class="memory-list" id="io-list" style="display:none;"></div>

    <!-- WiFi list (hidden initially) -->
    <div id="wifi-panel" style="display:none;padding:8px;overflow:auto;">
      <!-- WiFi Status -->
      <div style="margin-bottom:12px;padding:8px;background:rgba(255,255,255,0.02);border-radius:6px;">
        <div style="font-size:12px;color:#9aa3b2;margin-bottom:6px;">Status</div>
        <div id="wifi-status" style="font-size:13px;color:#fff;"></div>
      </div>

      <!-- Scan Button -->
      <button id="wifi-scan-btn" style="width:100%;padding:8px;margin-bottom:8px;background:#2563eb;border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:12px;">Scan Networks</button>

      <!-- Saved credentials banner (shown when saved creds exist but not connected) -->
      <div id="wifi-saved-banner" style="display:none;margin-top:8px;padding:8px;background:#1f2937;border-radius:6px;border:1px solid #334155;color:#fff;">
        <div style="font-size:13px;margin-bottom:6px;">Saved WiFi credentials found but not connected to STA.</div>
        <div style="display:flex;gap:8px;">
          <button id="wifi-autoconnect-retry" style="flex:1;padding:8px;background:#059669;border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:12px;">Auto Reconnect</button>
          <button id="wifi-forget-saved" style="flex:1;padding:8px;background:#dc2626;border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:12px;">Delete Saved Credentials</button>
        </div>
      </div>

      <!-- Networks List -->
      <div style="margin-bottom:12px;">
        <div style="font-size:12px;color:#9aa3b2;margin-bottom:6px;">Available Networks</div>
        <div id="wifi-networks" style="display:flex;flex-direction:column;gap:6px;max-height:200px;overflow:auto;">
          <div style="font-size:12px;color:#9aa3b2;">Click "Scan Networks" to find WiFi</div>
        </div>
      </div>

      <!-- Connect Form -->
      <div style="margin-bottom:12px;padding:8px;background:rgba(255,255,255,0.02);border-radius:6px;">
        <div style="font-size:12px;color:#9aa3b2;margin-bottom:6px;">Connect</div>
        <input type="text" id="wifi-ssid-input" placeholder="SSID" style="width:100%;padding:6px;margin-bottom:6px;border:1px solid #40506b;background:#122235;color:#fff;border-radius:4px;box-sizing:border-box;font-size:12px;">
        <input type="password" id="wifi-password-input" placeholder="Password" style="width:100%;padding:6px;margin-bottom:6px;border:1px solid #40506b;background:#122235;color:#fff;border-radius:4px;box-sizing:border-box;font-size:12px;">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
          <label style="display:flex;align-items:center;gap:8px;color:#9aa3b2;font-size:13px;"><input id="wifi-save-checkbox" type="checkbox" checked>Auto Reconnect</label>
        </div>
        <button id="wifi-connect-btn" style="width:100%;padding:6px;background:#059669;border:none;color:#fff;border-radius:4px;cursor:pointer;font-size:12px;margin-bottom:8px;">Connect</button>
        <button id="wifi-disconnect-btn" style="width:100%;padding:6px;background:#dc2626;border:none;color:#fff;border-radius:4px;cursor:pointer;font-size:12px;margin-bottom:8px;">Disconnect WiFi</button>
        <label style="color:#9aa3b2;font-size:13px;display:flex;align-items:center;gap:8px;margin-bottom:8px;">Auto Reconnect Settings</label>
		<label style="color:#9aa3b2;font-size:12px;display:flex;align-items:center;gap:8px;">Retry Interval (s): <input id="wifi-retry-interval" type="number" min="1" value="5" style="width:20px;padding:3px;font-size:12px;border-radius:4px;border:1px solid #40506b;background:rgba(255,255,255,0.02);color:#fff;border-radius:4px;box-sizing:border-box;font-size:12px;text-align: center;"></label>
        <label style="color:#9aa3b2;font-size:12px;display:flex;align-items:center;gap:8px;">Retry Count: <input id="wifi-retry-attempts" type="number" min="1" value="3" style="width:20px;padding:3px;font-size:12px;border-radius:4px;border:1px solid #40506b;background:rgba(255,255,255,0.02);color:#fff;border-radius:4px;box-sizing:border-box;font-size:12px;text-align: center;"></label>
      </div>
    </div>
  </div>
</div>

<!-- WiFi Connected Modal -->
<div id="wifi-modal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:2000;align-items:center;justify-content:center;">
  <div style="background:#0f1724;color:#fff;border-radius:12px;padding:24px;box-shadow:0 20px 60px rgba(0,0,0,0.6);text-align:center;min-width:280px;max-width:400px;">
    <div style="font-size:28px;margin-bottom:12px;">✓</div>
    <h2 style="font-size:18px;font-weight:600;margin:0 0 8px 0;">WiFi 연결됨</h2>
    <div id="wifi-modal-content" style="font-size:13px;color:#9aa3b2;margin-bottom:20px;line-height:1.6;"></div>
    <button id="wifi-modal-btn" style="padding:10px 24px;background:#2563eb;border:none;color:#fff;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;">확인</button>
  </div>
</div>

<div id="zoom-controls">
  <button data-z="-">−</button>
  <button data-z="1">⦿</button>
  <button data-z="+">＋</button>
</div>

<!-- Save Filename Modal -->
<div id="save-modal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:2001;align-items:center;justify-content:center;">
  <div style="background:#0f1724;color:#fff;border-radius:12px;padding:18px;box-shadow:0 20px 60px rgba(0,0,0,0.6);text-align:center;min-width:260px;max-width:420px;">
    <div style="font-size:16px;font-weight:700;margin-bottom:8px;">파일 이름 지정</div>
    <div style="font-size:13px;color:#9aa3b2;margin-bottom:12px;">내보낼 파일 이름을 입력하세요</div>
    <input id="save-filename-input" type="text" style="width:100%;padding:8px;border-radius:6px;border:1px solid #334155;background:#071127;color:#fff;box-sizing:border-box;margin-bottom:12px;" />
    <div style="display:flex;gap:8px;justify-content:center;">
      <button id="save-filename-cancel" style="padding:8px 14px;background:#334155;border:none;color:#fff;border-radius:6px;cursor:pointer;">취소</button>
      <button id="save-filename-ok" style="padding:8px 14px;background:#059669;border:none;color:#fff;border-radius:6px;cursor:pointer;">저장</button>
    </div>
  </div>
</div>

<!-- Mini Palette for port-to-open-space linking -->
<div id="mini-palette" style="min-width:60px;max-width:100px;width:80px;">
  <div class="mini-palette-items" style="display:flex;flex-direction:column;gap:8px;"></div>
</div>

<!-- hidden file input for import-from-file -->
<input type="file" id="import-file-input" accept=".json" style="display:none" />

<script>
// Ensure a safe global appendLog exists early so other scripts (WiFi, etc.)
// can call it before DOMContentLoaded runs.
window._consoleLogs = window._consoleLogs || [];
window.appendLog = window.appendLog || function(type, msg, ts){
  try{
    window._consoleLogs.unshift({ ts: ts || Date.now(), type: String(type||'debug'), msg: String(msg||'') });
    // Fallback to console for visibility when UI not ready
    console.log('[' + String(type||'debug').toUpperCase() + ']', msg);
  }catch(e){}
};

document.addEventListener("DOMContentLoaded", ()=>{

/* ---- DOM refs ---- */
const undoBtn=document.querySelector(".undo-btn");
const redoBtn=document.querySelector(".redo-btn");
const viewport=document.getElementById("viewport");
const svg=document.getElementById("lines");
const menuBtn=document.getElementById("menu-btn");
const menuPopup=document.getElementById("menu-popup");
const gridSnapCheckbox=document.getElementById("grid-snap-checkbox");
const flowWrapper=document.getElementById("flow-wrapper");
const statusBtns=document.querySelectorAll(".status-btn");
const deployBtn=document.getElementById("deploy-btn");
const selectionBox=document.getElementById("selection-box");
const pastePreview=document.getElementById("paste-preview");
const searchInput=document.getElementById("search");
const menuImport=document.getElementById("menu-import");
const menuImportFile=document.getElementById("menu-import-file");
const menuExport=document.getElementById("menu-export");
const menuVerify=document.getElementById("menu-verify");
const zoomControls = document.getElementById("zoom-controls");
const miniPalette = document.getElementById("mini-palette");
const miniPaletteItems = miniPalette.querySelector(".mini-palette-items");
const sidebar = document.getElementById("sidebar");
const errorList = document.getElementById("error-list"); // console log list
const memoryList = document.getElementById("memory-list");
const ioList = document.getElementById("io-list");
const closeSidebarBtn = document.getElementById("close-sidebar");
const clearErrorsBtn = document.getElementById("clear-errors");
const autoScrollBtn = document.getElementById("auto-scroll-btn");
const importFileInput = document.getElementById("import-file-input");
const debugBtn = document.querySelector('.status-btn.debug');

// Auto scroll 상태 관리
let autoScrollEnabled = true;

// WiFi 관련 요소들
const wifiScanBtn = document.getElementById("wifi-scan-btn");
const wifiConnectBtn = document.getElementById("wifi-connect-btn");
const wifiDisconnectBtn = document.getElementById("wifi-disconnect-btn");
const wifiSsidInput = document.getElementById("wifi-ssid-input");
const wifiPasswordInput = document.getElementById("wifi-password-input");
const wifiNetworks = document.getElementById("wifi-networks");
const wifiStatus = document.getElementById("wifi-status");

// Determine device host: prefer current page host, else default to common ESP32 AP IP
const serverHost = window.location.hostname && window.location.hostname.length > 0 ? window.location.hostname : '192.168.4.1';

/* filter checkboxes */
const filterError = document.getElementById("filter-error");
const filterDebug = document.getElementById("filter-debug");
const filterWs = document.getElementById("filter-ws");
const filterSystem = document.getElementById("filter-system");

/* Rebuild palette with categories */
const palette = document.getElementById("palette");
palette.innerHTML = '<div class="palette-search"><input id="search" placeholder="Search node" autocomplete="off"></div>';
const categories = {
  "Network": [
    { type: "network", label: "Network" },
  ],	
  "Basic": [
    { type: "open", label: "Open" },
    { type: "close", label: "Close" },
    { type: "rising", label: "Rising" },
    { type: "falling", label: "Falling" },
    { type: "invert", label: "Invert" }
  ],
  "Coils": [
    { type: "coil", label: "Coil" },
    { type: "set", label: "Set" },
    { type: "reset", label: "Reset" }
  ],

  "Instruction": [
    { type: "instruction", label: "INS" }
  ]
};
for (const [cat, items] of Object.entries(categories)) {
  const catDiv = document.createElement("div");
  catDiv.className = "palette-category";
  const header = document.createElement("div");
  header.className = "palette-category-header";
  header.textContent = cat;
  header.addEventListener("click", () => {
    content.style.display = content.style.display === "none" ? "block" : "none";
  });
  catDiv.appendChild(header);
  const content = document.createElement("div");
  content.className = "palette-category-content";
  items.forEach(item => {
    const itemDiv = document.createElement("div");
    itemDiv.className = "palette-item";
    itemDiv.draggable = true;
    itemDiv.dataset.type = item.type;
    itemDiv.textContent = item.label;
    content.appendChild(itemDiv);
  });
  catDiv.appendChild(content);
  palette.appendChild(catDiv);
}

/* Add tabs behavior */
const tabs = document.querySelectorAll('#sidebar .tab');
const tabContents = {
  console: document.getElementById('error-list'),
  memory: document.getElementById('memory-list'),
  io: document.getElementById('io-list'),
  wifi: document.getElementById('wifi-panel')
};
tabs.forEach(tab => {
  tab.addEventListener('click', () => {
    tabs.forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    Object.values(tabContents).forEach(c => {
      if(c) c.style.display = 'none';
    });
    const active = tab.dataset.tab;
    if(tabContents[active]) {
      tabContents[active].style.display = (active === 'console' ? 'block' : 'block');
    }
    // show/hide underlying control areas:
    document.getElementById('console-controls').style.display = (active === 'console') ? 'flex' : 'none';
    // WiFi 패널이 보여질 때 상태 업데이트
    if(active === 'wifi') {
      updateWiFiStatus();
    }
  });
});
/* ensure Console controls visible by default */
document.getElementById('console-controls').style.display = 'flex';

/* ---- Helper: return only real nodes that are direct children of #viewport ---- */
function realNodes(){
  return Array.from(viewport.children).filter(el=>el.classList && el.classList.contains("node"));
}

/* ---- State ---- */
let nodeId = 0; // numeric
let draggingNode = null, sx, sy, ox, oy, zoom = 1, dragLink = null;
let links = [], selectedNode = null, selectedLink = null;
let undoStack = [], redoStack = [], clipboard = null, pasteMode = false;
let selectedNodes = new Set(), dragSelect = false, selectStartX, selectStartY;
let gridSize = 20, snapToGrid = true;
let ws;
let consoleLogs = []; // {ts,type,msg,seen}
let isModified = false;

/* Track latest dragLink mouse position for palette */
let dragLinkMouse = { x:0, y:0 };

/* Current PLC status received from device (e.g. "RUN","STOP","ERROR",...) */
let currentPlcStatus = null;
let lastMemory = {};
let pasteCompletedAt = 0;

/* ---- Mini Palette Node Types ---- */
const nodeTypes = [
  { type: "network", label: "Network" },
  { type: "open", label: "Open" },
  { type: "close", label: "Close" },
  { type: "rising", label: "Rising" },
  { type: "falling", label: "Falling" },
  { type: "invert", label: "Invert" },
  { type: "coil", label: "Coil" },
  { type: "set", label: "Set" },
  { type: "reset", label: "Reset" },
  { type: "instruction", label: "INS" }
];
miniPaletteItems.innerHTML = "";
nodeTypes.forEach(nt => {
  const btn = document.createElement("button");
  btn.textContent = nt.label;
  btn.dataset.type = nt.type;
  btn.style.display = "inline-block";
  btn.style.padding = "4px 10px";
  btn.style.fontSize = "12px";
  btn.style.margin = "2px";
  btn.style.borderRadius = "8px";
  btn.style.border = "1px solid #ddd";
  btn.style.background = "#f6f7fa";
  btn.style.cursor = "pointer";
  btn.onmouseover = () => { btn.style.background = "#feecc8"; };
  btn.onmouseout = () => { btn.style.background = "#f6f7fa"; };
  miniPaletteItems.appendChild(btn);
});
miniPalette.addEventListener("mousedown", e => e.stopPropagation()); // prevent closing palette when clicking
// Hide on escape or click elsewhere
document.addEventListener("mousedown", e => { miniPalette.style.display = "none"; });
document.addEventListener("keydown", e=>{
  if(e.key === "Escape" && miniPalette.style.display === "block"){
    miniPalette.style.display = "none";
  }
});
miniPalette.addEventListener("click", e => {
  const btn = e.target.closest("button[data-type]");
  if(!btn) return;
  miniPalette.style.display = "none";
  // Create the new node at the dropped position (align with grid)
  const type = btn.dataset.type;
  // find viewport offset for this mouse pos
  const rect = viewport.getBoundingClientRect();
  const mouseX = miniPalette._startXY ? miniPalette._startXY.x : window.innerWidth/2;
  const mouseY = miniPalette._startXY ? miniPalette._startXY.y : window.innerHeight/2;
  // compute center coordinates (createNode expects centerX/centerY)
  const centerX = ((mouseX - rect.left) / zoom);
  const centerY = ((mouseY - rect.top) / zoom);
  const newNode = createNode(type, snapToGridCoord(centerX), snapToGridCoord(centerY));
  // Connect to the dragged port
  let portA = miniPalette._dragFrom;
  let portB = null;
  // find the opposite port on the new node
  if(portA.classList.contains("out")){
    portB = newNode.querySelector(".port.in");
    finalizeLink(portA, portB);
  } else {
    portB = newNode.querySelector(".port.out");
    finalizeLink(portB, portA);
  }
  pushState();
});

/* ---- Utilities ---- */
function getViewportBounds(){
    const style = getComputedStyle(viewport);
    let vw = parseInt(style.width) || viewport.offsetWidth || 3000;
    let vh = parseInt(style.height) || viewport.offsetHeight || 2000;
    return { vw, vh };
}

/* ---- WebSocket & status handling ---- */
function initWebSocketClient() {
    try {
    const host = serverHost;
    ws = new WebSocket(`ws://${host}/ws`);
        ws.onopen = () => { console.log('WebSocket connected.'); appendLog('system', 'WebSocket connected.'); };
        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log('Received WS data:', data); // Debug log
                // status messages
                if(data.status) {
                  currentPlcStatus = String(data.status);
                  updatePlcStatusButtons(data.status);
                }
                // debug flag (optional)
                if(typeof data.debug !== 'undefined'){
                  const dbgBtn = document.querySelector('.status-btn.debug');
                  if(dbgBtn) {
                    if(data.debug) dbgBtn.classList.add('active'); else dbgBtn.classList.remove('active');
                  }
                }
                // memory visualization
                if(data.memory){
                  // Normalize memory keys from device: device may send numeric keys (e.g. {"10":123})
                  // but UI expects prefixed keys like "D10", "M1", "I0", "Q0".
                  function prefixKeys(src, prefix){
                    const out = {};
                    if(!src) return out;
                    Object.keys(src).forEach(k=>{
                      let key = String(k).toUpperCase();
                      // If key is numeric ("10") -> prefix it
                      if(/^\d+$/.test(key)) key = prefix + key;
                      // If key already has prefix (d10 -> D10) normalize casing
                      else if(!key.startsWith(prefix)){
                        // strip any leading letter and re-add prefix if needed
                        const m = key.match(/^(?:[DMIQ])(.+)$/i);
                        if(m) key = prefix + m[1];
                        else key = prefix + key;
                      }
                      out[key] = src[k];
                    });
                    return out;
                  }

                  const flatMemory = Object.assign({},
                    prefixKeys(data.memory.d || {}, 'D'), // D words
                    prefixKeys(data.memory.m || {}, 'M'), // M bits
                    prefixKeys(data.memory.i || {}, 'I'), // I inputs
                    prefixKeys(data.memory.q || {}, 'Q')  // Q outputs
                  );
                  // Keep T and C as nested objects for detailed display
                  if(data.memory.t) flatMemory.t = data.memory.t;
                  if(data.memory.c) flatMemory.c = data.memory.c;
                    // Prefer node-level states if provided by firmware
                    const nodeStates = data.nodeStates || null;
                    updateNodeVisualization(flatMemory, nodeStates);
                  // also update lists
                  updateMemoryList(flatMemory);
                  updateIOList(flatMemory);
                }
                // logs from device (structured)
                if(data.log){
                  const type = data.log.type || 'debug';
                  const msg = data.log.msg || JSON.stringify(data.log);
                  appendLog(type, msg, data.log.ts || Date.now());
                }
                // plain error field
                if(data.error){
                  appendLog('error', data.error);
                }
            } catch (e) { console.error("Failed to parse WebSocket message:", e); appendLog('debug', 'WS parse error: '+ (e.message || e)); }
        };
        ws.onclose = () => {
            console.warn('WebSocket disconnected. Reconnect in 5s...');
            appendLog('system','WebSocket disconnected. Reconnect scheduled.');
            updatePlcStatusButtons("ERROR");
            setTimeout(initWebSocketClient, 5000);
        };
        ws.onerror = (err) => { console.error('WebSocket error', err); appendLog('debug','WebSocket error'); };
    } catch(e) {
        console.warn('WebSocket init skipped', e);
        appendLog('system','WebSocket init skipped');
    }
}

/* Update topbar status buttons according to device state */
function updatePlcStatusButtons(newStatus){
    // Remove previous active state and deploying marker
    statusBtns.forEach(b=>{ b.classList.remove("active","deploying"); });
    if(!newStatus) return;
    const btn = Array.from(statusBtns).find(b=>b.dataset.mode === newStatus);
    if(btn){
      btn.classList.add("active");
      // show deploying text on deploy button if needed
      if(newStatus === "DEPLOYING"){
        deployBtn.classList.add('deploying');
        deployBtn.textContent = "Deploying...";
      } else {
        deployBtn.classList.remove('deploying');
        deployBtn.textContent = "Deploy";
      }
    } else {
      deployBtn.classList.remove('deploying');
      deployBtn.textContent = "Deploy";
    }
}

// Evaluate whether node is logically 'energized' according to its type.
function evaluateNodeActive(node, activeMemory, lastMem){
  const type = (node.dataset.type || "open").toString();
  const addrEl = node.querySelector(".addr");
  if(!addrEl) return false;
  let raw = (addrEl.textContent || "").trim();
  if(!raw) return false;
  raw = raw.toUpperCase();

  // helper: read current and previous values from activeMemory/lastMem
  function readMemory(key, mem){
    if(!mem) return 0;
    if(typeof mem[key] !== 'undefined') return mem[key];
    return 0;
  }

  // support bit addressing like D10.3 (bit 3 of D10)
  let currVal = 0, prevVal = 0;
  const bitMatch = raw.match(/^(D)(\d+)\.(\d+)$/i);
  if(bitMatch){
    const wordKey = 'D' + bitMatch[2];
    const bit = Number(bitMatch[3]) || 0;
    const wordCurr = Number(readMemory(wordKey, activeMemory)) || 0;
    const wordPrev = Number(readMemory(wordKey, lastMem)) || 0;
    currVal = ((wordCurr >> bit) & 1) ? 1 : 0;
    prevVal = ((wordPrev >> bit) & 1) ? 1 : 0;
  } else {
    // direct key lookup (M, I, Q, D, IW, QW, etc.)
    currVal = readMemory(raw, activeMemory);
    prevVal = readMemory(raw, lastMem);
    // normalize numeric strings to numbers
    if(typeof currVal === 'string' && currVal.match(/^\d+$/)) currVal = Number(currVal);
    if(typeof prevVal === 'string' && prevVal.match(/^\d+$/)) prevVal = Number(prevVal);
  }

  const curr = !!currVal; // treat non-zero as true for contacts
  const prev = !!prevVal;

  switch(type){
    case "open":   // NO - conducts when bit true
      return curr;
    case "close":  // NC - conducts when bit false
      return !curr;
    case "invert": // NEG - inverts signal
      return !curr;
    case "rising": // RE - edge true on transition 0->1
      return (!prev && curr);
    case "falling":// FE - edge true on transition 1->0
      return (prev && !curr);
    case "coil":
    case "set":
    case "reset":
      return curr;
    case "instruction": // treat instruction as truthy when its address/value non-zero
      return curr;
    default:
      return curr;
  }
}

// Update visualization: apply .active-high based on evaluated logical state.
// Additionally, detect rising/falling events to trigger blink & history.
function updateNodeVisualization(activeMemory, nodeStates){
  console.log('Updating visualization with memory:', activeMemory, 'nodeStates:', nodeStates);
  if(!activeMemory) return;
  realNodes().forEach(n=>{
    // clear visual active state first
    n.classList.remove("active-high");
        // remove existing edge blink if animation ended (kept safe)
        // actual removal will be done by timeout below.
        try{
          const addrEl = n.querySelector(".addr");
          const instEl = n.querySelector('.instruction');
          const argsEl = n.querySelector('.args');
          const wordValEl = n.querySelector('.word-val');
          const rawAddr = addrEl ? (addrEl.textContent || '').trim().toUpperCase() : '';
          const nodeState = nodeStates && n.dataset.id ? nodeStates[n.dataset.id] : null;
          const type = (n.dataset.type || "open").toString();
          // NETWORK 노드는 PLC가 RUN 상태일 때 항상 활성(녹색) 표시
          if (type === 'network' && typeof currentPlcStatus !== 'undefined' && String(currentPlcStatus).toUpperCase() === 'RUN') {
            n.classList.add('active-high');
            return;
          }
          
          // If PLC provided node-level state, use it preferentially
          if(nodeState){
            if(typeof nodeState.active !== 'undefined'){
              if(nodeState.active) n.classList.add('active-high'); else n.classList.remove('active-high');
            }
            if(nodeState.wordVal && wordValEl){ wordValEl.textContent = String(nodeState.wordVal); wordValEl.style.display = ''; }
            // skip local evaluation when nodeState present
            return;
          }

          // Instruction nodes: show values of args (D1:D2 etc.) and determine activation
          if(type === 'instruction' && argsEl && wordValEl){
            const argsText = (argsEl.textContent || '').trim();
            const tokens = argsText.split(/[:,\s]+/).map(t=>t.trim()).filter(t=>t.length>0);
            // helper to read a token value (supports Dn.m bit access)
            function readToken(tok){
              if(!tok) return 0;
              const t = tok.toUpperCase();
              const bitMatch = t.match(/^D(\d+)\.(\d+)$/i);
              if(bitMatch){
                const wordKey = 'D' + bitMatch[1];
                const bit = Number(bitMatch[2]) || 0;
                const wordCurr = Number(activeMemory[wordKey] || 0);
                return ((wordCurr >> bit) & 1) ? 1 : 0;
              }
              const v = activeMemory[t];
              if(typeof v === 'undefined') return 0;
              return v;
            }

            // Show values next to node and on top badge
            const parts = tokens.map(t => `${t}=${String(readToken(t))}`);
            wordValEl.textContent = parts.join(' ');
            wordValEl.style.display = '';
            // also update value badge (concise): prefer timer/counter formatting below,
            // otherwise show first token value
            const badge = n.querySelector('.value-badge');
            if(badge){
              const first = tokens[0] || '';
              const v = String(readToken(first));
              badge.textContent = v;
              badge.style.display = 'inline-block';
            }

            // Helper: check upstream network satisfaction by recursively requiring all inbound sources be active
            function networkSatisfied(node, visited = new Set()){
              const nid = node.dataset.id;
              if(visited.has(nid)) return true;
              visited.add(nid);
              const inbound = links.filter(l => l.to.parentElement === node);
              if(inbound.length === 0){
                return !!evaluateNodeActive(node, activeMemory, lastMemory);
              }
              for(const l of inbound){
                const fromNode = l.from.parentElement;
                // require the immediate predecessor to evaluate true
                if(!evaluateNodeActive(fromNode, activeMemory, lastMemory)) return false;
                // and its upstream must also be satisfied
                if(!networkSatisfied(fromNode, visited)) return false;
              }
              return true;
            }

            const instCode = (instEl && instEl.textContent) ? instEl.textContent.trim().split(/\s|[:]/)[0].toUpperCase() : '';
            const compareSet = new Set(['EQ','NE','GT','GE','LT','LE']);
            const arithSet = new Set(['ADD','SUB','MUL','DIV','MOD','SHL','SHR','ROL','ROR','MOVE']);

            // 타이머/카운터 검사: args의 첫 토큰이 T... 또는 C...인 경우, 장치에서 전달된 memory 객체의 Q 상태를 우선 반영
            if(tokens.length > 0){
              const firstTok = tokens[0].toUpperCase();
              const badge = n.querySelector('.value-badge');
              if(/^T\d+/i.test(firstTok) && activeMemory && activeMemory.t){
                const tObj = activeMemory.t[firstTok];
                if(tObj){
                  // show timer current/preset on node and badge
                  if(wordValEl) { wordValEl.textContent = `${tObj.current}/${tObj.preset}ms`; wordValEl.style.display = ''; }
                  if(badge){ badge.textContent = `${tObj.current}/${tObj.preset}`; badge.style.display = 'inline-block'; }
                  if(tObj.q) n.classList.add('active-high'); else n.classList.remove('active-high');
                } else {
                  if(badge) { badge.textContent = '0'; badge.style.display = 'inline-block'; }
                }
                // already handled timer display - skip further instruction evaluation
                return;
              }
              if(/^C\d+/i.test(firstTok) && activeMemory && activeMemory.c){
                const cObj = activeMemory.c[firstTok];
                if(cObj){
                  if(wordValEl) { wordValEl.textContent = `${cObj.current}/${cObj.preset}`; wordValEl.style.display = ''; }
                  if(badge){ badge.textContent = `${cObj.current}/${cObj.preset}`; badge.style.display = 'inline-block'; }
                  if(cObj.q) n.classList.add('active-high'); else n.classList.remove('active-high');
                } else {
                  if(badge) { badge.textContent = '0'; badge.style.display = 'inline-block'; }
                }
                return;
              }
            }

            if(compareSet.has(instCode)){
              // comparison: require two operands
              if(tokens.length >= 2){
                const a = Number(readToken(tokens[0]) || 0);
                const b = Number(readToken(tokens[1]) || 0);
                let res = false;
                switch(instCode){
                  case 'EQ': res = (a === b); break;
                  case 'NE': res = (a !== b); break;
                  case 'GT': res = (a > b); break;
                  case 'GE': res = (a >= b); break;
                  case 'LT': res = (a < b); break;
                  case 'LE': res = (a <= b); break;
                }
                if(res) n.classList.add('active-high'); else n.classList.remove('active-high');
              } else {
                n.classList.remove('active-high');
              }
            } else if(arithSet.has(instCode)){
              // arithmetic/move/etc: display as coil-like — active only when upstream network conditions satisfied
              if(networkSatisfied(n)) n.classList.add('active-high'); else n.classList.remove('active-high');
            } else {
              // default: fallback to previous behavior (first arg truthy)
              if(tokens.length>0){
                const destVal = readToken(tokens[0]);
                if(destVal) n.classList.add('active-high'); else n.classList.remove('active-high');
              }
            }
          }
          // Check for Timer nodes (e.g., T1, T2)
          const timerMatch = rawAddr.match(/^T(\d+)$/i);
            if(timerMatch && activeMemory.t) {
            const timerName = rawAddr;
            const timer = activeMemory.t[timerName];
            if(timer && wordValEl) {
              // Display timer current/preset value
              wordValEl.textContent = `${timer.current}/${timer.preset}ms`;
              wordValEl.style.display = '';
              const badge = n.querySelector('.value-badge'); if(badge){ badge.textContent = `${timer.current}/${timer.preset}`; badge.style.display = 'inline-block'; }
              // If Q=1, add active-high class for green highlighting
              if(timer.q) {
                n.classList.add("active-high");
              }
            }
          }
          // Check for Counter nodes (e.g., C1, C2)
          else if(rawAddr.match(/^C(\d+)$/i) && activeMemory.c) {
            const counterName = rawAddr;
            const counter = activeMemory.c[counterName];
            if(counter && wordValEl) {
              // Display counter current/preset value
              wordValEl.textContent = `${counter.current}/${counter.preset}`;
              wordValEl.style.display = '';
              const badge = n.querySelector('.value-badge'); if(badge){ badge.textContent = `${counter.current}/${counter.preset}`; badge.style.display = 'inline-block'; }
              // If Q=1, add active-high class for green highlighting
              if(counter.q) {
                n.classList.add("active-high");
              }
            }
          }
          // If address is a D word (e.g. D10), show its numeric value on the node
          else {
            const dWordMatch = rawAddr.match(/^D(\d+)$/i);
            if(dWordMatch && wordValEl){
              const key = 'D' + dWordMatch[1];
              const v = typeof activeMemory[key] !== 'undefined' ? activeMemory[key] : 0;
              wordValEl.textContent = String(v);
              wordValEl.style.display = '';
            } else if(wordValEl){
              wordValEl.style.display = 'none';
            }
            
            const isActive = evaluateNodeActive(n, activeMemory, lastMemory);
            if(isActive) n.classList.add("active-high");
          }

          // Edge detection specifically for rising/falling nodes
          if(type === "rising" && (!prev && curr)){
            triggerEdgeEvent(n, addr, "rising");
          } else if(type === "falling" && (prev && !curr)){
            triggerEdgeEvent(n, addr, "falling");
          }
        }catch(e){}
    });
    // shallow copy for next comparison
    lastMemory = Object.assign({}, activeMemory);
    updateMemoryList(activeMemory);
    updateIOList(activeMemory);
}

// Trigger visual blink and push to edge history
function triggerEdgeEvent(nodeEl, addr, edgeType){
  // visual blink: add class and remove after 1s (clear previous timeout if any)
  try{
    if(nodeEl._edgeTimeout) { clearTimeout(nodeEl._edgeTimeout); nodeEl._edgeTimeout = null; }
    nodeEl.classList.add("edge-blink");
    nodeEl._edgeTimeout = setTimeout(()=>{ nodeEl.classList.remove("edge-blink"); nodeEl._edgeTimeout = null; }, 1000);
  }catch(e){}
}

/* ---- Console log functions with filtering ---- */
function formatTs(ts){
  const d = new Date(ts);
  return d.toLocaleString();
}
function appendLog(type, msg, ts){
  const t = ts || Date.now();
  consoleLogs.unshift({ts:t,type: String(type||'debug'),msg:String(msg||'')});
  renderLogList();
}
function renderLogList(){
  errorList.innerHTML = "";
  const filter = {
    error: filterError.checked,
    debug: filterDebug.checked,
    ws: filterWs.checked,
    system: filterSystem.checked
  };
  consoleLogs.forEach((e, idx)=>{
    if(e.type === 'error' && !filter.error) return;
    if(e.type === 'debug' && !filter.debug) return;
    if(e.type === 'ws' && !filter.ws) return;
    if(e.type === 'system' && !filter.system) return;
    const div = document.createElement("div");
    div.className = "log-entry";
    const tt = document.createElement("div"); tt.className="ts"; tt.textContent = `[${e.type.toUpperCase()}] ${formatTs(e.ts)}`;
    const m = document.createElement("div"); m.className="msg"; m.textContent = e.msg;
    div.appendChild(tt); div.appendChild(m);
    errorList.appendChild(div);
  });
  // 스크롤바 및 자동 스크롤
  errorList.style.overflowY = "auto";
  errorList.style.maxHeight = "calc(100vh - 180px)";
  // 자동 스크롤 활성화 여부 확인 (맨 위로 스크롤)
  if(autoScrollEnabled) {
    errorList.scrollTop = 0;
  }
}

/* Add change listeners for console filter checkboxes (fix: missing listeners) */
[filterError, filterDebug, filterWs, filterSystem].forEach(ch => {
  if(ch) ch.addEventListener('change', renderLogList);
});

/* Update memory list in sidebar
   - Grouped by type (M, D, T, C)
   - Only show memory locations referenced by nodes or present in activeMemory
   - Show assigned tag when available
*/
function gatherUsedMemoryAndTags(){
  const used = { M:new Set(), D:new Set(), T:new Set(), C:new Set(), I:new Set(), Q:new Set(), IW:new Set(), QW:new Set() };
  const tagMap = {}; // addr->tag
  const addrRegex = /\b(IW?\d+|QW?\d+|I\d+|Q\d+|M\d+|D\d+(?:\.\d+)?|T\d+|C\d+)\b/ig;
  realNodes().forEach(n=>{
    const addrText = (n.querySelector('.addr')?.textContent||'').trim();
    const tagText = (n.querySelector('.tag')?.textContent||'').trim();
    const instArgs = (n.querySelector('.args')?.textContent||'').trim();
    const searchArea = (addrText + ' ' + instArgs);
    const matches = searchArea.match(addrRegex) || [];
    matches.forEach(m=>{
      const token = m.toUpperCase();
      if(token.startsWith('M')) used.M.add(token);
      else if(token.startsWith('D')) {
        // normalize bit notation D10.3 to D10 for word listing if needed
        const bitMatch = token.match(/^D(\d+)\.(\d+)$/i);
        if(bitMatch) used.D.add('D' + bitMatch[1]);
        else used.D.add(token);
      }
      else if(token.startsWith('T')) used.T.add(token);
      else if(token.startsWith('C')) used.C.add(token);
      else if(token.startsWith('IW')) used.IW.add(token);
      else if(token.startsWith('QW')) used.QW.add(token);
      else if(token.startsWith('I')) used.I.add(token);
      else if(token.startsWith('Q')) used.Q.add(token);

      // tag association (prefer explicit tag if present and not placeholder)
      if(tagText && !n.querySelector('.tag').classList.contains('placeholder')){
        tagMap[token] = tagText;
      } else {
        // if tag not present, try to preserve existing mapping (leave undefined)
      }
    });
  });
  return {used, tagMap};
}

function updateMemoryList(activeMemory){
  const memList = document.getElementById("memory-list");
  if(!memList) return;
  memList.innerHTML = "";

  const { used, tagMap } = gatherUsedMemoryAndTags();

  // Helper to create section
  function createSection(title){
    const header = document.createElement('div'); header.className = 'memory-item';
    const strong = document.createElement('strong'); strong.textContent = title;
    header.appendChild(strong);
    memList.appendChild(header);
    return memList;
  }

  // M bits section (show only used M addresses or those present in activeMemory)
  createSection('M (bits)');
  const mKeys = new Set([...used.M]);
  // also include any M present in activeMemory object
  if(activeMemory){
    Object.keys(activeMemory).forEach(k=>{
      if(/^M\d+$/i.test(k)) mKeys.add(k.toUpperCase());
    });
  }
  const mSorted = Array.from(mKeys).sort((a,b)=> {
    const na = Number(a.match(/\d+/)?.[0]||0);
    const nb = Number(b.match(/\d+/)?.[0]||0);
    return na - nb;
  });
  if(mSorted.length === 0){
    const none = document.createElement('div'); none.className='memory-item'; none.style.opacity=0.6; none.textContent = 'No M bits used';
    memList.appendChild(none);
  } else {
    mSorted.forEach(addr=>{
      const val = activeMemory && typeof activeMemory[addr] !== 'undefined' ? activeMemory[addr] : 0;
      const item = document.createElement('div'); item.className = 'memory-item';
      const addrSpan = document.createElement('span'); addrSpan.className = 'addr'; addrSpan.textContent = addr;
      const tagSpan = document.createElement('span'); tagSpan.className = 'addr'; tagSpan.style.marginLeft='8px'; tagSpan.style.color='#9ad3ff'; tagSpan.textContent = tagMap[addr] ? tagMap[addr] : '';
      const valueSpan = document.createElement('span'); valueSpan.className = 'value'; valueSpan.textContent = (val ? '1' : '0');
      item.appendChild(addrSpan); if(tagSpan.textContent) item.appendChild(tagSpan); item.appendChild(valueSpan);
      memList.appendChild(item);
    });
  }

  // D words section
  createSection('D (words)');
  const dKeys = new Set([...used.D]);
  if(activeMemory){
    Object.keys(activeMemory).forEach(k=>{
      if(/^D\d+$/i.test(k)) dKeys.add(k.toUpperCase());
    });
  }
  const dSorted = Array.from(dKeys).sort((a,b)=>{
    const na = Number(a.match(/\d+/)?.[0]||0);
    const nb = Number(b.match(/\d+/)?.[0]||0);
    return na - nb;
  });
  if(dSorted.length === 0){
    const none = document.createElement('div'); none.className='memory-item'; none.style.opacity=0.6; none.textContent = 'No D words used';
    memList.appendChild(none);
  } else {
    dSorted.forEach(addr=>{
      const val = activeMemory && typeof activeMemory[addr] !== 'undefined' ? activeMemory[addr] : 0;
      const item = document.createElement('div'); item.className = 'memory-item';
      const addrSpan = document.createElement('span'); addrSpan.className = 'addr'; addrSpan.textContent = addr;
      const tagSpan = document.createElement('span'); tagSpan.className = 'addr'; tagSpan.style.marginLeft='8px'; tagSpan.style.color='#9ad3ff'; tagSpan.textContent = tagMap[addr] ? tagMap[addr] : '';
      const valueSpan = document.createElement('span'); valueSpan.className = 'value'; valueSpan.textContent = String(val);
      item.appendChild(addrSpan); if(tagSpan.textContent) item.appendChild(tagSpan); item.appendChild(valueSpan);
      memList.appendChild(item);
    });
  }

  // T timers
  createSection('T (timers)');
  const tKeys = new Set([...used.T]);
  if(activeMemory && activeMemory.t){
    Object.keys(activeMemory.t).forEach(k=> tKeys.add(k.toUpperCase()));
  }
  const tSorted = Array.from(tKeys).sort((a,b)=>{
    const na = Number(a.match(/\d+/)?.[0]||0);
    const nb = Number(b.match(/\d+/)?.[0]||0);
    return na - nb;
  });
  if(tSorted.length === 0){
    const none = document.createElement('div'); none.className='memory-item'; none.style.opacity=0.6; none.textContent = 'No Timers used';
    memList.appendChild(none);
  } else {
    tSorted.forEach(addr=>{
      const timer = activeMemory && activeMemory.t ? activeMemory.t[addr] : null;
      const display = timer ? `Q:${timer.q?1:0} ${timer.current||0}/${timer.preset||0}` : 'N/A';
      const item = document.createElement('div'); item.className = 'memory-item';
      const addrSpan = document.createElement('span'); addrSpan.className = 'addr'; addrSpan.textContent = addr;
      const tagSpan = document.createElement('span'); tagSpan.className = 'addr'; tagSpan.style.marginLeft='8px'; tagSpan.style.color='#9ad3ff'; tagSpan.textContent = tagMap[addr] ? tagMap[addr] : '';
      const valueSpan = document.createElement('span'); valueSpan.className = 'value'; valueSpan.textContent = display;
      item.appendChild(addrSpan); if(tagSpan.textContent) item.appendChild(tagSpan); item.appendChild(valueSpan);
      memList.appendChild(item);
    });
  }

  // C counters
  createSection('C (counters)');
  const cKeys = new Set([...used.C]);
  if(activeMemory && activeMemory.c){
    Object.keys(activeMemory.c).forEach(k=> cKeys.add(k.toUpperCase()));
  }
  const cSorted = Array.from(cKeys).sort((a,b)=>{
    const na = Number(a.match(/\d+/)?.[0]||0);
    const nb = Number(b.match(/\d+/)?.[0]||0);
    return na - nb;
  });
  if(cSorted.length === 0){
    const none = document.createElement('div'); none.className='memory-item'; none.style.opacity=0.6; none.textContent = 'No Counters used';
    memList.appendChild(none);
  } else {
    cSorted.forEach(addr=>{
      const counter = activeMemory && activeMemory.c ? activeMemory.c[addr] : null;
      const display = counter ? `Q:${counter.q?1:0} ${counter.current||0}/${counter.preset||0}` : 'N/A';
      const item = document.createElement('div'); item.className = 'memory-item';
      const addrSpan = document.createElement('span'); addrSpan.className = 'addr'; addrSpan.textContent = addr;
      const tagSpan = document.createElement('span'); tagSpan.className = 'addr'; tagSpan.style.marginLeft='8px'; tagSpan.style.color='#9ad3ff'; tagSpan.textContent = tagMap[addr] ? tagMap[addr] : '';
      const valueSpan = document.createElement('span'); valueSpan.className = 'value'; valueSpan.textContent = display;
      item.appendChild(addrSpan); if(tagSpan.textContent) item.appendChild(tagSpan); item.appendChild(valueSpan);
      memList.appendChild(item);
    });
  }
}

/* ---- I/O list: I, IW, Q, QW (show only used or present in activeMemory) ---- */
function updateIOList(activeMemory){
  const list = document.getElementById("io-list");
  if(!list) return;
  list.innerHTML = "";

  const { used, tagMap } = gatherUsedMemoryAndTags();

  function createSection(title){
    const header = document.createElement('div'); header.className = 'memory-item';
    const strong = document.createElement('strong'); strong.textContent = title;
    header.appendChild(strong);
    list.appendChild(header);
  }

  // I (inputs)
  createSection('I (Inputs)');
  const iKeys = new Set([...used.I]);
  if(activeMemory){
    Object.keys(activeMemory).forEach(k=>{
      if(/^I\d+$/i.test(k)) iKeys.add(k.toUpperCase());
    });
  }
  const iSorted = Array.from(iKeys).sort((a,b)=> Number(a.match(/\d+/)?.[0]||0) - Number(b.match(/\d+/)?.[0]||0));
  if(iSorted.length === 0){
    const none = document.createElement('div'); none.className='memory-item'; none.style.opacity=0.6; none.textContent = 'No digital Inputs used';
    list.appendChild(none);
  } else {
    iSorted.forEach(addr=>{
      const val = activeMemory && typeof activeMemory[addr] !== 'undefined' ? activeMemory[addr] : 0;
      const item = document.createElement('div'); item.className = 'memory-item';
      const addrSpan = document.createElement('span'); addrSpan.className = 'addr'; addrSpan.textContent = addr;
      const tagSpan = document.createElement('span'); tagSpan.className = 'addr'; tagSpan.style.marginLeft='8px'; tagSpan.style.color='#9ad3ff'; tagSpan.textContent = tagMap[addr] ? tagMap[addr] : '';
      const valueSpan = document.createElement('span'); valueSpan.className = 'value'; valueSpan.textContent = (val ? '1' : '0');
      item.appendChild(addrSpan); if(tagSpan.textContent) item.appendChild(tagSpan); item.appendChild(valueSpan);
      list.appendChild(item);
    });
  }

  // IW (analog inputs / words)
  createSection('IW (Analog Inputs)');
  const iwKeys = new Set([...used.IW]);
  if(activeMemory){
    Object.keys(activeMemory).forEach(k=>{
      if(/^IW\d+$/i.test(k)) iwKeys.add(k.toUpperCase());
    });
  }
  const iwSorted = Array.from(iwKeys).sort((a,b)=> Number(a.match(/\d+/)?.[0]||0) - Number(b.match(/\d+/)?.[0]||0));
  if(iwSorted.length === 0){
    const none = document.createElement('div'); none.className='memory-item'; none.style.opacity=0.6; none.textContent = 'No IW used';
    list.appendChild(none);
  } else {
    iwSorted.forEach(addr=>{
      const val = activeMemory && typeof activeMemory[addr] !== 'undefined' ? activeMemory[addr] : 0;
      const item = document.createElement('div'); item.className = 'memory-item';
      const addrSpan = document.createElement('span'); addrSpan.className = 'addr'; addrSpan.textContent = addr;
      const tagSpan = document.createElement('span'); tagSpan.className = 'addr'; tagSpan.style.marginLeft='8px'; tagSpan.style.color='#9ad3ff'; tagSpan.textContent = tagMap[addr] ? tagMap[addr] : '';
      const valueSpan = document.createElement('span'); valueSpan.className = 'value'; valueSpan.textContent = String(val);
      item.appendChild(addrSpan); if(tagSpan.textContent) item.appendChild(tagSpan); item.appendChild(valueSpan);
      list.appendChild(item);
    });
  }

  // Q (outputs)
  createSection('Q (Outputs)');
  const qKeys = new Set([...used.Q]);
  if(activeMemory){
    Object.keys(activeMemory).forEach(k=>{
      if(/^Q\d+$/i.test(k)) qKeys.add(k.toUpperCase());
    });
  }
  const qSorted = Array.from(qKeys).sort((a,b)=> Number(a.match(/\d+/)?.[0]||0) - Number(b.match(/\d+/)?.[0]||0));
  if(qSorted.length === 0){
    const none = document.createElement('div'); none.className='memory-item'; none.style.opacity=0.6; none.textContent = 'No digital Outputs used';
    list.appendChild(none);
  } else {
    qSorted.forEach(addr=>{
      const val = activeMemory && typeof activeMemory[addr] !== 'undefined' ? activeMemory[addr] : 0;
      const item = document.createElement('div'); item.className = 'memory-item';
      const addrSpan = document.createElement('span'); addrSpan.className = 'addr'; addrSpan.textContent = addr;
      const tagSpan = document.createElement('span'); tagSpan.className = 'addr'; tagSpan.style.marginLeft='8px'; tagSpan.style.color='#9ad3ff'; tagSpan.textContent = tagMap[addr] ? tagMap[addr] : '';
      const valueSpan = document.createElement('span'); valueSpan.className = 'value'; valueSpan.textContent = (val ? '1' : '0');
      item.appendChild(addrSpan); if(tagSpan.textContent) item.appendChild(tagSpan); item.appendChild(valueSpan);
      list.appendChild(item);
    });
  }

  // QW (analog outputs / words)
  createSection('QW (Analog Outputs)');
  const qwKeys = new Set([...used.QW]);
  if(activeMemory){
    Object.keys(activeMemory).forEach(k=>{
      if(/^QW\d+$/i.test(k)) qwKeys.add(k.toUpperCase());
    });
  }
  const qwSorted = Array.from(qwKeys).sort((a,b)=> Number(a.match(/\d+/)?.[0]||0) - Number(b.match(/\d+/)?.[0]||0));
  if(qwSorted.length === 0){
    const none = document.createElement('div'); none.className='memory-item'; none.style.opacity=0.6; none.textContent = 'No QW used';
    list.appendChild(none);
  } else {
    qwSorted.forEach(addr=>{
      const val = activeMemory && typeof activeMemory[addr] !== 'undefined' ? activeMemory[addr] : 0;
      const item = document.createElement('div'); item.className = 'memory-item';
      const addrSpan = document.createElement('span'); addrSpan.className = 'addr'; addrSpan.textContent = addr;
      const tagSpan = document.createElement('span'); tagSpan.className = 'addr'; tagSpan.style.marginLeft='8px'; tagSpan.style.color='#9ad3ff'; tagSpan.textContent = tagMap[addr] ? `(${tagMap[addr]})` : '';
      const valueSpan = document.createElement('span'); valueSpan.className = 'value'; valueSpan.textContent = String(val);
      item.appendChild(addrSpan); if(tagSpan.textContent) item.appendChild(tagSpan); item.appendChild(valueSpan);
      list.appendChild(item);
    });
  }
}

if (!window.memoryClickAdded) {
  const memList = document.getElementById("memory-list");
  if (memList) {
    memList.addEventListener('click', function(e) {
      const item = e.target.closest('.memory-item');
      if (item && !item.querySelector('strong')) { // 헤더 제외
        const addrSpan = item.querySelector('.addr');
        const valueSpan = item.querySelector('.value');
        if (addrSpan && valueSpan) {
          const addr = addrSpan.textContent.trim();
          const currentVal = valueSpan.textContent;
          
          // D words: 숫자 입력, 나머지: 토글
          if(addr.startsWith('D')){
            const newVal = prompt(`Enter value for ${addr}:`, currentVal);
            if(newVal !== null){
              try{ ws.send(`SET ${addr} ${parseInt(newVal) || 0}`); }catch(e){ appendLog('debug','WS send error: '+(e.message||e)); }
            }
          } else {
            // Bits: 토글 (true/false 또는 1/0)
            const isBinary = currentVal === '1' || currentVal === '0';
            const currentBool = (currentVal === '1' || currentVal === 'true');
            const newVal = currentBool ? 0 : 1;
            try{ ws.send(`SET ${addr} ${newVal}`); }catch(e){ appendLog('debug','WS send error: '+(e.message||e)); }
          }
        }
      }
    });
    window.memoryClickAdded = true;
  }
}

/* Clear / open / close sidebar helpers */
function clearLogs(){ consoleLogs = []; renderLogList(); }
function openSidebar(){ sidebar.classList.add("open"); sidebar.setAttribute("aria-hidden","false"); }
function closeSidebar(){ sidebar.classList.remove("open"); sidebar.setAttribute("aria-hidden","true"); }

/* DEBUG button: toggle console open/close */
if(debugBtn){
  debugBtn.addEventListener("click", ()=>{
    if(sidebar.classList.contains("open")) closeSidebar();
    else openSidebar();
  });
}

// Wire clear and close buttons
if(clearErrorsBtn){
  clearErrorsBtn.addEventListener("click", ()=>{
    clearLogs();
  });

  // Auto Scroll 버튼 토글
  // 초기 상태: 파란색으로 활성화됨
  if(autoScrollBtn) {
    autoScrollBtn.style.background = "#2563eb";
  }
  
  autoScrollBtn.addEventListener("click", ()=>{
    autoScrollEnabled = !autoScrollEnabled;
    autoScrollBtn.style.background = autoScrollEnabled ? "#2563eb" : "#334155";
    autoScrollBtn.style.color = autoScrollEnabled ? "#fff" : "#fff";
    renderLogList();
  });
}

if(closeSidebarBtn){
  closeSidebarBtn.addEventListener("click", ()=>{
    closeSidebar();
  });
}

// Wire topbar RUN/STOP/RESET/DEBUG buttons to WebSocket commands
if(statusBtns && typeof ws !== 'undefined'){
  Array.from(statusBtns).forEach(b=>{
    // Skip disabled ERROR button
    if(b.classList.contains('error')) return;
    b.addEventListener('click', ()=>{
      const mode = b.dataset.mode;
      if(!mode) return;
      try{
        if(ws && ws.readyState === WebSocket.OPEN){
          // Map UI mode to simple text commands expected by firmware
          if(mode === 'RUN' || mode === 'STOP' || mode === 'RESET' || mode === 'DEBUG'){
            ws.send(mode);
            appendLog('debug', 'WS send: '+mode);
          }
        } else {
          appendLog('debug','WS not connected');
        }
      }catch(e){ appendLog('debug','WS send error: '+(e.message||e)); }
    });
  });
}

/* ---- Editable fields ---- */
function makeEditable(el, ph){
    // For instruction fields we use the dedicated picker, avoid default inline input
    if (el.classList && el.classList.contains && el.classList.contains('instruction')) {
      return;
    }
    el.ondblclick = e => {
    const i = document.createElement("input");
    i.value = el.classList.contains("placeholder") ? "" : el.textContent;
    i.style.width = "120px";
    i.style.fontSize = "14px";
    i.style.padding = "4px";
    i.style.border = "1px solid #ccc";
    i.style.borderRadius = "6px";
    i.style.boxSizing = "border-box";
    i.style.background = "#fff";
    i.style.color = "#0b1220";
    el.innerHTML = "";
    el.appendChild(i);
    i.focus();
    i.select();
    const finish = () => {
      const v = i.value.trim();
      el.textContent = v || ph;
      if(v) el.classList.remove("placeholder"); else el.classList.add("placeholder");
      pushState();
    };
    i.onblur = finish;
    i.onkeydown = e => { if(e.key === "Enter") finish(); };
  };
}

  // ---- Instruction picker for nodes ----
  const instructionCommands = [
    "TON","TOFF","TP","CTU","CTD","ADD","SUB","MUL","DIV","MOD",
    "SHL","SHR","ROL","ROR","AND","OR","XOR","NOT",
    "EQ","GT","GE","LT","LE","NE","MOVE"
  ];

  const instructionExamples = {
    "TON": "T1:1000", // Timer address:time_ms
    "TOFF": "T1:1000", // Timer address:time_ms
    "TP": "T1:1000", // Timer address:time_ms
    "CTU": "C1:10", // Counter address:preset
    "CTD": "C1:10", // Counter address:preset
    "ADD": "D1:D2:D3", // Result:Op1:Op2
    "SUB": "D1:D2:D3", // Result:Op1:Op2
    "MUL": "D1:D2:D3", // Result:Op1:Op2
    "DIV": "D1:D2:D3", // Result:Op1:Op2
    "MOD": "D1:D2:D3", // Result:Op1:Op2
    "SHL": "D1:D2", // Value:ShiftAmount
    "SHR": "D1:D2", // Value:ShiftAmount
    "ROL": "D1:D2", // Value:ShiftAmount
    "ROR": "D1:D2", // Value:ShiftAmount
    "AND": "D1:D2:D3", // Result:Op1:Op2
    "OR": "D1:D2:D3", // Result:Op1:Op2
    "XOR": "D1:D2:D3", // Result:Op1:Op2
    "NOT": "D1:D2", // Result:Op
    "EQ": "D1:D2", // Op1:Op2
    "GT": "D1:D2", // Op1:Op2
    "GE": "D1:D2", // Op1:Op2
    "LT": "D1:D2", // Op1:Op2
    "LE": "D1:D2", // Op1:Op2
    "NE": "D1:D2", // Op1:Op2
    "MOVE": "D1:D2" // Dest:Src
  };

  function openInstructionPicker(targetEl){
    // remove existing picker
    const existing = document.getElementById('instr-picker'); if(existing) existing.remove();
    const rect = targetEl.getBoundingClientRect();
    const picker = document.createElement('div'); picker.id = 'instr-picker';
    picker.style.position = 'absolute'; picker.style.zIndex = 2000;
    // size the picker to match the node width (fallback to 220px), but clamp maximum
    const rawWidth = Math.round(rect.width || 220);
    const nodeWidth = Math.max(120, Math.min(rawWidth || 220, 360));
    // position below the node and clamp to viewport so it doesn't overflow
    let leftPos = Math.round(rect.left + window.scrollX);
    const topPos = Math.round(rect.bottom + window.scrollY + 6);
    const viewportW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const maxLeft = Math.round(window.scrollX + viewportW - nodeWidth - 8);
    if (leftPos > maxLeft) leftPos = Math.max(window.scrollX + 8, maxLeft);
    picker.style.left = leftPos + 'px'; picker.style.top = topPos + 'px';
    picker.style.width = nodeWidth + 'px'; picker.style.background = '#fff'; picker.style.border = '1px solid #ccc'; picker.style.borderRadius = '6px'; picker.style.boxShadow = '0 8px 24px rgba(0,0,0,.12)'; picker.style.padding = '8px'; picker.style.zIndex = 99999;

    const input = document.createElement('input'); input.type = 'text'; input.placeholder = 'Search instruction';
    input.style.width = '80%'; input.style.boxSizing = 'border-box'; input.style.padding = '6px'; input.style.marginBottom = '6px'; input.style.border = '1px solid #ddd';
    picker.appendChild(input);

    const list = document.createElement('div'); list.style.maxHeight = '240px'; list.style.overflow = 'auto'; list.style.display = 'flex'; list.style.flexDirection = 'column'; list.style.gap = '4px'; list.style.background = 'transparent';
    picker.appendChild(list);

    function renderItems(filter){
      list.innerHTML = '';
      const f = (filter||'').toLowerCase();
      const items = instructionCommands.filter(it => it.toLowerCase().includes(f));
      items.forEach((it, idx) => {
        const row = document.createElement('div'); row.textContent = it + ' (' + (instructionExamples[it] || '') + ')'; row.tabIndex = 0;
        row.style.padding = '6px 8px'; row.style.cursor = 'pointer'; row.style.borderRadius = '4px'; row.style.color = '#0b1220';
        row.onmouseenter = ()=>{ row.style.background = '#f1f5f9'; };
        row.onmouseleave = ()=>{ row.style.background = 'transparent'; };
        row.onclick = ()=>{ selectItem(it); };
        list.appendChild(row);
      });
      if(items.length > 0) {
        // highlight first
        const first = list.children[0]; if(first) first.style.background = '#eef2ff';
      }
    }

    function selectItem(value){
      targetEl.textContent = value; targetEl.classList.remove('placeholder');
      // Set args example
      const argsEl = targetEl.parentNode.querySelector('.args');
      if (argsEl && instructionExamples[value]) {
        argsEl.textContent = instructionExamples[value];
        argsEl.classList.remove('placeholder');
      }
      picker.remove(); targetEl.focus(); pushState();
    }

    input.addEventListener('input', e=>{ renderItems(e.target.value); });
    input.addEventListener('keydown', e=>{
      if(e.key === 'Escape'){ picker.remove(); }
      else if(e.key === 'Enter'){
        // choose first filtered item
        const first = list.children[0]; if(first) selectItem(first.textContent);
      }
      else if(e.key === 'ArrowDown'){
        const f = list.children[0]; if(f) f.focus(); e.preventDefault();
      }
    });

    // keyboard navigation inside list
    list.addEventListener('keydown', e=>{
      const cur = document.activeElement; if(!cur) return;
      if(e.key === 'ArrowDown'){ if(cur.nextSibling) (cur.nextSibling).focus(); e.preventDefault(); }
      else if(e.key === 'ArrowUp'){ if(cur.previousSibling) (cur.previousSibling).focus(); else input.focus(); e.preventDefault(); }
      else if(e.key === 'Enter'){ selectItem(cur.textContent); }
      else if(e.key === 'Escape'){ picker.remove(); }
    });

    document.body.appendChild(picker);
    // initial render
    renderItems(targetEl.textContent || '');
    setTimeout(()=>{ input.focus(); input.select(); }, 10);

    // click outside closes picker
    const onDocClick = (ev)=>{ if(!picker.contains(ev.target)) { picker.remove(); document.removeEventListener('mousedown', onDocClick); } };
    document.addEventListener('mousedown', onDocClick);
  }

  function openInstructionDropdown(targetEl){
    // If already editing, return
    if(targetEl.querySelector('select')) return;
    const currentValue = targetEl.classList.contains('placeholder') ? '' : targetEl.textContent;
    const select = document.createElement('select');
    select.style.width = '100%';
    select.style.fontSize = '13px';
    select.style.padding = '2px';
    select.style.border = '1px solid #ccc';
    select.style.borderRadius = '4px';
    select.style.background = '#fff';
    select.style.color = '#0b1220';
    // Add options
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'Select Instruction';
    select.appendChild(defaultOption);
    instructionCommands.forEach(cmd => {
      const option = document.createElement('option');
      option.value = cmd;
      option.textContent = cmd + ' (' + (instructionExamples[cmd] || '') + ')';
      if(cmd === currentValue) option.selected = true;
      select.appendChild(option);
    });
    // Hide text and show select
    targetEl.textContent = '';
    targetEl.appendChild(select);
    select.focus();
    const finish = () => {
      const selected = select.value;
      targetEl.innerHTML = '';
      if(selected) {
        targetEl.textContent = selected;
        targetEl.classList.remove('placeholder');
        // Set args example
        const argsEl = targetEl.parentNode.querySelector('.args');
        if(argsEl && instructionExamples[selected]) {
          argsEl.textContent = instructionExamples[selected];
          argsEl.classList.remove('placeholder');
        }
      } else {
        targetEl.textContent = 'Instruction';
        targetEl.classList.add('placeholder');
      }
      pushState();
    };
    select.addEventListener('change', finish);
    select.addEventListener('blur', finish);
    select.addEventListener('keydown', e => {
      if(e.key === 'Enter') finish();
      if(e.key === 'Escape') {
        targetEl.innerHTML = currentValue || 'Instruction';
        if(!currentValue) targetEl.classList.add('placeholder');
      }
    });
  }

/* ---- Snapshot / History (improved) ---- */
/* pushState: avoid pushing duplicate consecutive snapshots
   now accepts noMark=true to avoid marking the deploy button as modified
*/
function snapshot(){
  // Produce compact JSON compatible with ESP32 loader:
  // nodes: [{id:int,networkId:int,type:string,addr:string,tag:string,setpoint:int,instruction:string,args:string,x:int,y:int}]
  // linkData: [{from:int,to:int}]
  const nodes = realNodes().map(n=>{
    const id = Number(n.dataset.id) || 0;
    // Preserve networkId as string (keep "N0", "N1" or "-1" when absent)
    const networkId = (typeof n.dataset.networkId !== 'undefined' && n.dataset.networkId !== null && String(n.dataset.networkId).trim() !== '') 
                      ? String(n.dataset.networkId).trim()
                      : "-1";
    const addrEl = n.querySelector('.addr');
    const tagEl = n.querySelector('.tag');
    const spEl = n.querySelector('.setpoint');
    const instEl = n.querySelector('.instruction');
    const argsEl = n.querySelector('.args');
    return {
      id: id,
      networkId: networkId,    // <- keep as string now
      x: parseInt(n.style.left) || 0,
      y: parseInt(n.style.top) || 0,
      type: (n.dataset.type && n.dataset.type.toLowerCase() === 'instruction') ? 'instruction' : (n.dataset.type || 'open'),
      addr: addrEl ? (addrEl.classList.contains('placeholder') ? "" : addrEl.textContent.trim()) : "",
      tag: tagEl ? (tagEl.classList.contains('placeholder') ? "" : tagEl.textContent.trim()) : "",
      setpoint: spEl ? parseInt(spEl.textContent) || 0 : 0,
      instruction: instEl ? (instEl.classList.contains('placeholder') ? "" : instEl.textContent.trim()) : "",
      args: argsEl ? (argsEl.classList.contains('placeholder') ? "" : argsEl.textContent.trim()) : ""
    };
  });
  const linkData = links.map(l=>({ 
    from: Number(l.from.parentElement.dataset.id) || 0, 
    to: Number(l.to.parentElement.dataset.id) || 0,
    fromPort: l.from.classList.contains('out') ? 'out' : 'in',
    toPort: l.to.classList.contains('out') ? 'out' : 'in'
  }));
  nodes.sort((a,b)=> a.id - b.id);
  return JSON.stringify({nodes,linkData,nodeId: Number(nodeId) || 0});
}
function applySnapshot(json){
  const data = JSON.parse(json);
  // remove existing real nodes & links
  realNodes().forEach(n=>n.remove());
  links.forEach(l=>{ l.path?.remove(); l.hit?.remove(); });
  links = [];
  selectedNodes.clear();
  selectedNode = null;
  selectedLink = null;

  // recreate nodes; track max numeric id to keep nodeId unique
  let maxIdSeen = Number(data.nodeId) || nodeId || 0;
  const symbols = {open:"[ ]",network:"[NET]",close:"[/]",rising:"[↑]",falling:"[↓]",invert:"[NOT]",coil:"( )",set:"(S)",reset:"(R)",instruction:"[INS]"};

  (data.nodes||[]).forEach(n=>{
    // 항상 소문자 type 사용 (특히 instruction)
    let type = n.type || "open";
    if (typeof type === "string" && type.toLowerCase() === "instruction") type = "instruction";
    
    // centerX, centerY 또는 x, y 호환성 처리
    let centerX, centerY;
    if (typeof n.centerX === "number" && typeof n.centerY === "number") {
      // 새 포맷: centerX, centerY (중심점 기준)
      centerX = n.centerX;
      centerY = n.centerY;
    } else {
      // 구 포맷: x, y (좌상단 기준) - 중심점으로 변환
      const oldX = (typeof n.x === "number") ? n.x : parseInt(n.x) || 0;
      const oldY = (typeof n.y === "number") ? n.y : parseInt(n.y) || 0;
      const nodeHeight = getNodeHeight(type);
      centerX = oldX + 75;  // 노드 너비 150 / 2
      centerY = oldY + nodeHeight / 2;
    }
    
    const id = String(n.id);
    const addr = (n.addr && n.addr.length) ? n.addr : "";
    const tag = (n.tag && n.tag.length) ? n.tag : "";
    const setpoint = n.setpoint || null;
    const instruction = (n.instruction && n.instruction.length) ? n.instruction : "";
    const args = (n.args && n.args.length) ? n.args : "";
    const created = createNode(
      type,
      centerX,
      centerY,
      id,
      (addr && addr.length ? addr : null),
      (tag && tag.length ? tag : null),
      setpoint,
      true,
      (instruction && instruction.length ? instruction : null),
      (args && args.length ? args : null)
    );
    // Store networkId in dataset for later
    if(typeof n.networkId !== 'undefined') {
      created.dataset.networkId = String(n.networkId);
    } else {
      created.dataset.networkId = '-1';
    }
    const sym = created.querySelector(".symbol");
    if(sym) sym.textContent = symbols[type] || symbols["open"];
    const addrEl = created.querySelector(".addr");
    const tagEl = created.querySelector(".tag");
    if(addrEl) { if(!addr) addrEl.classList.add("placeholder"); else addrEl.classList.remove("placeholder"); }
    if(tagEl) { if(!tag) tagEl.classList.add("placeholder"); else tagEl.classList.remove("placeholder"); }
    // set setpoint display if present
    if(n.setpoint && created.querySelector('.setpoint')) created.querySelector('.setpoint').textContent = String(n.setpoint);
    // set instruction/args display if present
    if(created.querySelector('.instruction')) {
      if(instruction) {
        created.querySelector('.instruction').textContent = instruction;
        created.querySelector('.instruction').classList.remove("placeholder");
      } else {
        created.querySelector('.instruction').textContent = "Instruction";
        created.querySelector('.instruction').classList.add("placeholder");
      }
    }
    if(created.querySelector('.args')) {
      if(args) {
        created.querySelector('.args').textContent = args;
        created.querySelector('.args').classList.remove("placeholder");
      } else {
        created.querySelector('.args').textContent = "Args";
        created.querySelector('.args').classList.add("placeholder");
      }
    }


    const numericId = Number(id);
    if(!Number.isNaN(numericId)) maxIdSeen = Math.max(maxIdSeen, numericId);
  });

  (data.linkData||[]).forEach(l=>{
    const fromNode = document.querySelector(`.node[data-id="${l.from}"]`);
    const toNode = document.querySelector(`.node[data-id="${l.to}"]`);
    if(fromNode && toNode){
      const fromPortClass = l.fromPort || 'out';
      const toPortClass = l.toPort || 'in';
      const fromPort = fromNode.querySelector(`.port.${fromPortClass}`);
      const toPort = toNode.querySelector(`.port.${toPortClass}`);
      if(fromPort && toPort) finalizeLink(fromPort, toPort);
    }
  });

  nodeId = Math.max(nodeId, maxIdSeen || 0, Number(data.nodeId) || 0);
}

/* pushState: avoid pushing duplicate consecutive snapshots
   noMark = true -> do not mark deploy button as modified (used after imports from device)
*/
function pushState(noMark){
  const s = snapshot();
  if(undoStack.length && undoStack[undoStack.length-1] === s){
    redoStack = [];
    return;
  }
  redoStack = [];
  undoStack.push(s);
  if(undoStack.length > 80) undoStack.shift();
  if(!noMark) setModified(true);
}

/* set deploy modified state */
function setModified(v){
  isModified = !!v;
  if(isModified) deployBtn.classList.add('modified');
  else deployBtn.classList.remove('modified');
}

/* undo/redo */
undoBtn.onclick = ()=> undo();
redoBtn.onclick = ()=> redo();
function undo(){
  if(!undoStack.length) return;
  const current = snapshot();
  const prev = undoStack.pop();
  redoStack.push(current);
  applySnapshot(prev);
  setModified(true);
}
function redo(){
  if(!redoStack.length) return;
  const current = snapshot();
  const next = redoStack.pop();
  undoStack.push(current);
  applySnapshot(next);
  setModified(true);
}

/* ---- Menu, UI wiring ---- */
menuBtn.addEventListener("click", e=>{ e.stopPropagation(); menuPopup.style.display = (menuPopup.style.display === "block" ? "none" : "block"); });
document.addEventListener("click", ()=>{ menuPopup.style.display = "none"; });
menuPopup.addEventListener("click", e=> e.stopPropagation());
gridSnapCheckbox.addEventListener("change", e=> snapToGrid = e.target.checked);
searchInput.addEventListener("input", e=>{
  const q = e.target.value.toLowerCase();
  document.querySelectorAll(".palette-item").forEach(item=>{
    const text = item.textContent.toLowerCase();
    item.style.display = text.includes(q) ? "block" : "none";
  });
});

menuImport.addEventListener("click", ()=> {
  if(confirm("현재 편집 중인 로직은 저장되지 않습니다. ESP32의 로직을 불러오시겠습니까?")) fetchAndApplyLogic("/load", false);
});
menuVerify.addEventListener("click", ()=> fetchAndApplyLogic("/verify", true));
menuExport.addEventListener("click", async ()=>{
  // show modal to get filename, then download
  showSaveFilenameModal('plc_logic.json', (filename) => {
    try {
      const json = snapshot();
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = filename || 'plc_logic.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 1500);
      alert('현재 로직을 다운로드했습니다.');
    } catch(err) {
      console.error(err);
      alert('내보내기 실패: ' + (err && err.message ? err.message : err));
    }
  });
});

// Import from file: open hidden file input, read and apply as snapshot
menuImportFile.addEventListener("click", ()=>{
  if(confirm("현재 편집 중인 로직은 저장되지 않습니다. 파일에서 로직을 불러오시겠습니까?")){
    importFileInput.value = "";
    importFileInput.click();
  }
});
importFileInput.addEventListener("change", async (e)=>{
  const f = importFileInput.files[0];
  if(!f) return;
  try{
    const txt = await f.text();
    applySnapshot(txt);
    pushState(); // this counts as modification (user changed the flow)
    alert("파일에서 로직을 불러왔습니다.");
  }catch(err){
    alert("파일 읽기 실패: " + (err.message || err));
  }
});

/* ---- Status buttons send commands via WebSocket (improved) ---- */
Array.from(statusBtns).forEach(btn=>{
  // ERROR button should have no action (disabled). DEBUG handled separately.
  if(btn.dataset.mode === "ERROR") return;
  if(btn.dataset.mode === "DEBUG") return;
  btn.addEventListener("click", ()=>{
    const mode = btn.dataset.mode;
    if(ws && ws.readyState === WebSocket.OPEN){
      if(mode === "RESET"){
        if(!confirm("PLC 메모리 및 설정을 초기화하고 재부팅하시겠습니까?")) return;
      }
      ws.send(mode);
      // optimistic UI change (final state will be reconfirmed by server)
      updatePlcStatusButtons(mode);
      appendLog('system','Sent: ' + mode);
    } else {
      alert("WebSocket not connected. 명령을 전송할 수 없습니다.");
      appendLog('debug','Attempted to send command while WS closed: ' + mode);
    }
  });
});

/* ---- Helper: Calculate node height based on type ---- */
function getNodeHeight(type) {
  type = String(type || "open").toLowerCase();
  // 기본 노드: symbol(32px) + addr(22px) + tag(22px) + ports(14px) + padding/margin ≈ 110px
  // INS 노드: 위 + instruction(22px) + args(22px) ≈ 154px
  if(type === "instruction") return 154;
  return 110;
}

/* ---- Node creation and behavior (HARDENED) ---- */
function createNode(type, centerX, centerY, id = null, a = null, t = null, s = null, noSnap = false, inst = null, args = null){
  // 항상 소문자 type 사용 (특히 instruction)
  if (typeof type === "string" && type.toLowerCase() === "instruction") type = "instruction";
  type = type || "open";
  centerX = (typeof centerX === "number") ? centerX : parseInt(centerX) || 0;
  centerY = (typeof centerY === "number") ? centerY : parseInt(centerY) || 0;

  const n = document.createElement("div");
  n.className = "node";
  
  // 중심점 저장 (dataset에 저장)
  n.dataset.centerX = String(centerX);
  n.dataset.centerY = String(centerY);
  
  // 렌더링할 좌상단 좌표 계산
  const nodeHeight = getNodeHeight(type);
  const nodeWidth = 150;
  const leftPos = centerX - nodeWidth / 2;
  const topPos = centerY - nodeHeight / 2;
  
  n.style.left = leftPos + "px";
  n.style.top = topPos + "px";

  if(id !== null && id !== undefined){
    const numeric = Number(id);
    if(!Number.isNaN(numeric)) nodeId = Math.max(nodeId, numeric);
    n.dataset.id = String(id);
  } else {
    nodeId = Number(nodeId) + 1;
    n.dataset.id = String(nodeId);
  }

  n.dataset.type = String(type);

  const symbols = {open:"[ ]",network:"[NET]",close:"[/]",rising:"[↑]",falling:"[↓]",invert:"[NOT]",coil:"( )",set:"(S)",reset:"(R)",instruction:"[INS]"};
  const sym = document.createElement("div");
  sym.className = "symbol";
  sym.textContent = symbols[type] || symbols["open"];

  // small value badge shown above instruction nodes (current/preset display)
  const valueBadge = document.createElement("div");
  valueBadge.className = "value-badge";
  valueBadge.textContent = "";

  const addr = document.createElement("div");
  addr.className = "addr";
  addr.textContent = (a !== null && a !== undefined) ? a : "Address";
  if(a === null || a === undefined) addr.classList.add("placeholder");

  const tag = document.createElement("div");
  tag.className = "tag";
  tag.textContent = (t !== null && t !== undefined) ? t : "Tag";
  if(t === null || t === undefined) tag.classList.add("placeholder");

  const wordVal = document.createElement("div");
  wordVal.className = "word-val";
  wordVal.textContent = "";
  wordVal.style.display = "none";

  makeEditable(addr, "Address");
  makeEditable(tag, "Tag");

  // Create type-specific fields
  let setpointField = null;
  let instField = null;
  let argsField = null;
  
  if(type === "instruction"){
    instField = document.createElement("div");
    instField.className = "instruction";
    instField.textContent = (inst !== null && inst !== undefined) ? inst : "Instruction";
    if(inst === null || inst === undefined) instField.classList.add("placeholder");
    // Instead of makeEditable, use dropdown on click
    instField.addEventListener('click', ()=>{ openInstructionDropdown(instField); });
    
    argsField = document.createElement("div");
    argsField.className = "args";
    argsField.textContent = (args !== null && args !== undefined) ? args : "Args";
    if(args === null || args === undefined) argsField.classList.add("placeholder");
    makeEditable(argsField, "Args");
  }

  const pi = document.createElement("div"), po = document.createElement("div");
  pi.className = "port in";
  po.className = "port out";

  [pi, po].forEach(p=>{
    p.onmousedown = e => {
      if(e.detail === 2) return;
      dragLink = { from: p, line: createTempPath() };
      dragLinkMouse = { x: e.clientX, y: e.clientY };
      e.stopPropagation();
    };
    p.onmouseup = e => {
      if(!dragLink) return;
      if(dragLink.from === p){
        if(dragLink.line && svg.contains(dragLink.line)) svg.removeChild(dragLink.line);
        dragLink = null;
        return;
      }
      finalizeLink(dragLink.from, p);
      if(dragLink.line && svg.contains(dragLink.line)) svg.removeChild(dragLink.line);
      dragLink = null;
      pushState();
    };
    p.ondblclick = e => { e.preventDefault(); e.stopPropagation(); };
  });

  n.append(sym);
  // attach value badge for instruction nodes (kept hidden for others)
  n.append(valueBadge);
  if(type !== "instruction") n.append(addr);
  n.append(wordVal);
  if(setpointField) n.append(setpointField);
  if(instField) n.append(instField);
  if(argsField) n.append(argsField);
  n.append(tag);
  n.append(pi, po);
  viewport.appendChild(n);

  if(!n.querySelector(".symbol")){
    const sym2 = document.createElement("div");
    sym2.className = "symbol";
    sym2.textContent = symbols[type] || symbols["open"];
    n.insertBefore(sym2, n.firstChild);
  }

  n.onmousedown = e => {
    if(e.target.classList.contains("port")) return;
    if(e.ctrlKey || e.metaKey || e.shiftKey){
      if(selectedNodes.has(n)) removeFromSelection(n);
      else addToSelection(n);
      return;
    }
    if(!selectedNodes.has(n)) selectNode(n);
    else if(selectedNodes.size > 1) selectedNode = n;

    selectedNodes.forEach(node=>{
      node.dataset.baseX = node.style.left;
      node.dataset.baseY = node.style.top;
    });

    draggingNode = n;
    sx = e.clientX; sy = e.clientY;
    ox = parseInt(n.style.left) || 0;
    oy = parseInt(n.style.top) || 0;
  };

  if(!noSnap) pushState();
  return n;
}

/* ---- Drag & drop from palette ---- */
let paletteDragType = null;
document.querySelectorAll(".palette-item").forEach(i=>{
  i.addEventListener("dragstart", e=>{
    e.dataTransfer.setData("type", i.dataset.type);
    paletteDragType = i.dataset.type;
    e.dataTransfer.effectAllowed = "copy";
    // Hide default drag image by setting empty image
    const emptyImage = new Image();
    e.dataTransfer.setDragImage(emptyImage, 0, 0);
  });
});
viewport.addEventListener("dragover", e => {
  e.preventDefault();
  if(paletteDragType) {
    e.dataTransfer.dropEffect = "copy";
    const r = viewport.getBoundingClientRect();
    const centerX = (e.clientX - r.left) / zoom;
    const centerY = (e.clientY - r.top) / zoom;
    updatePaletteDragPreview(paletteDragType, centerX, centerY);
  }
});
viewport.addEventListener("dragleave", e => {
  if(e.target === viewport) {
    pastePreview.innerHTML = "";
    pastePreview.style.display = "none";
  }
});
viewport.addEventListener("drop", e=>{
  const r = viewport.getBoundingClientRect();
  // compute center coords for createNode
  const centerX = (e.clientX - r.left) / zoom;
  const centerY = (e.clientY - r.top) / zoom;
  createNode(e.dataTransfer.getData("type"), centerX, centerY);
  pastePreview.innerHTML = "";
  pastePreview.style.display = "none";
  paletteDragType = null;
});

/* ---- Mouse move / selection box / dragging (with clamping) ---- */
document.addEventListener("mousemove", e=>{
  if(dragLink){ updateTempPath(dragLink.line, dragLink.from, e); return; }
  if(dragSelect){
    const r = viewport.getBoundingClientRect();
    const x = (e.clientX - r.left) / zoom;
    const y = (e.clientY - r.top) / zoom;
    const w = Math.abs(x - selectStartX);
    const h = Math.abs(y - selectStartY);
    const l = Math.min(x, selectStartX);
    const t = Math.min(y, selectStartY);
    selectionBox.style.left = l + "px";
    selectionBox.style.top = t + "px";
    selectionBox.style.width = w + "px";
    selectionBox.style.height = h + "px";

    realNodes().forEach(n=>{
      const nx = parseInt(n.style.left) || 0;
      const ny = parseInt(n.style.top) || 0;
      const nw = 150;
      const nh = n.offsetHeight;
      if(nx < l + w && nx + nw > l && ny < t + h && ny + nh > t) addToSelection(n);
      else if(!e.ctrlKey && !e.metaKey && !e.shiftKey) removeFromSelection(n);
    });
    return;
  }
  if(pasteMode){
    const r = viewport.getBoundingClientRect();
    const mouseX = (e.clientX - r.left) / zoom;
    const mouseY = (e.clientY - r.top) / zoom;
    updatePastePreview(snapToGridCoord(mouseX), snapToGridCoord(mouseY));
    return;
  }
  if(draggingNode){
    const dx = (e.clientX - sx) / zoom;
    const dy = (e.clientY - sy) / zoom;
    const bounds = getViewportBounds();
    const minX = 0, minY = 0;
    const maxX = Math.max(0, bounds.vw - 150);
    const maxY = Math.max(0, bounds.vh - 40);

    if(selectedNodes.size > 1){
      selectedNodes.forEach(n=>{
        const baseX = parseInt(n.dataset.baseX || n.style.left) || 0;
        const baseY = parseInt(n.dataset.baseY || n.style.top) || 0;
        const nw = 150;
        const nh = n.offsetHeight || getNodeHeight(n.dataset.type);
        // Convert top-left -> center, snap center, convert back so ports (center) align to grid
        const centerX = baseX + dx + nw/2;
        const centerY = baseY + dy + nh/2;
        let snappedCenterX = snapToGridCoord(centerX);
        let snappedCenterY = snapToGridCoord(centerY);
        let newX = snappedCenterX - nw/2;
        let newY = snappedCenterY - nh/2;
        const nodeMaxX = Math.max(0, bounds.vw - nw);
        const nodeMaxY = Math.max(0, bounds.vh - nh);
        newX = Math.min(Math.max(newX, minX), nodeMaxX);
        newY = Math.min(Math.max(newY, minY), nodeMaxY);
        n.style.left = newX + "px";
        n.style.top = newY + "px";
      });
    } else {
      const nw = 150;
      const nh = draggingNode.offsetHeight || getNodeHeight(draggingNode.dataset.type);
      // ox/oy are top-left; convert to center, snap, convert back
      const centerX = ox + dx + nw/2;
      const centerY = oy + dy + nh/2;
      let snappedCenterX = snapToGridCoord(centerX);
      let snappedCenterY = snapToGridCoord(centerY);
      let newX = snappedCenterX - nw/2;
      let newY = snappedCenterY - nh/2;
      const nodeMaxX = Math.max(0, bounds.vw - nw);
      const nodeMaxY = Math.max(0, bounds.vh - nh);
      newX = Math.min(Math.max(newX, minX), nodeMaxX);
      newY = Math.min(Math.max(newY, minY), nodeMaxY);
      draggingNode.style.left = newX + "px";
      draggingNode.style.top = newY + "px";
    }
    redrawLinks();
  }
});

/* ---- mouseup finalization ---- */
document.addEventListener("mouseup", e=>{
  if(draggingNode){
    selectedNodes.forEach(n=>{ delete n.dataset.baseX; delete n.dataset.baseY; });
    draggingNode = null;
    pushState();
  }
  // Mini palette trigger for link-to-open-space
  if(dragLink){
    if(dragLink.line && svg.contains(dragLink.line)) svg.removeChild(dragLink.line);
    // Only if NOT released on another port (done in port. mouseup)
    if(dragLink.from && !(e.target.classList && e.target.classList.contains("port"))){
      // Show the mini palette at cursor
      miniPalette.style.left = `${e.clientX}px`;
      miniPalette.style.top = `${e.clientY}px`;
      miniPalette.style.display = "block";
      // Remember: which port did we drag from? What coordinates?
      miniPalette._dragFrom = dragLink.from;
      miniPalette._startXY = { x: e.clientX, y: e.clientY };
    }
    dragLink = null;
  }
  if(dragSelect){
    dragSelect = false;
    selectionBox.style.display = "none";
  }
});

/* ---- Links: temp path + finalize + redraw ---- */
function createTempPath(){
  const p = document.createElementNS("http://www.w3.org/2000/svg","path");
  p.classList.add("link");
  p.setAttribute("stroke-dasharray","5,5");
  svg.appendChild(p);
  return p;
}
function updateTempPath(p, from, e){
  const r = viewport.getBoundingClientRect();
  const a = from.getBoundingClientRect();
  const x1 = (a.x + a.width/2 - r.left) / zoom;
  const y1 = (a.y + a.height/2 - r.top) / zoom;
  const x2 = (e.clientX - r.left) / zoom;
  const y2 = (e.clientY - r.top) / zoom;
  const offset = Math.max(40, Math.abs(x2 - x1) * .5);
  const dir = from.classList.contains("out") ? 1 : -1;
  p.setAttribute("d", `M${x1},${y1} C${x1 + offset*dir},${y1} ${x2 - offset*dir},${y2} ${x2},${y2}`);
}

// flash invalid ports visually
function flashInvalidPorts(p1, p2){
  try{
    p1.classList.add('invalid');
    p2.classList.add('invalid');
    setTimeout(()=>{ p1.classList.remove('invalid'); p2.classList.remove('invalid'); }, 600);
  }catch(e){}
}

// 1. Prevent self-port connection
function finalizeLink(from, to){
  // --- Prevent connecting node to its own other port ---
  if(from.parentElement === to.parentElement){
    flashInvalidPorts(from, to);
    return;
  }
  // Disallow out->out and in->in connections
  const fromOut = from.classList.contains('out');
  const toOut = to.classList.contains('out');
  if(fromOut === toOut){
    flashInvalidPorts(from, to);
    return;
  }
  // Prevent duplicate identical links
  const fromNode = from.parentElement;
  const toNode = to.parentElement;
  const fromPortName = fromOut ? 'out' : 'in';
  const toPortName = toOut ? 'out' : 'in';
  for(const l of links){
    if(l.from.parentElement === fromNode && l.to.parentElement === toNode &&
       (l.from.classList.contains('out') ? 'out' : 'in') === fromPortName &&
       (l.to.classList.contains('out') ? 'out' : 'in') === toPortName){
      flashInvalidPorts(from, to);
      return;
    }
  }

  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  const hit = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.classList.add("link");
  hit.classList.add("link-hit");
  
  // Store link source and target node IDs for validation
  const fromNodeId = fromNode.dataset.id;
  const toNodeId = toNode.dataset.id;
  path.dataset.linkFrom = fromNodeId;
  path.dataset.linkTo = toNodeId;
  hit.dataset.linkFrom = fromNodeId;
  hit.dataset.linkTo = toNodeId;
  
  svg.append(path, hit);
  const link = { from, to, path, hit };
  hit.onmousedown = e => { selectLink(link); };
  links.push(link);
  redrawLinks();
}
function redrawLinks(){
  links.forEach(l => { updatePath(l.path, l.from, l.to); updatePath(l.hit, l.from, l.to); });
}
function updatePath(p, from, to){
  const r = viewport.getBoundingClientRect();
  const a = from.getBoundingClientRect();
  const b = to.getBoundingClientRect();
  const x1 = (a.x + a.width/2 - r.left) / zoom;
  const y1 = (a.y + a.height/2 - r.top) / zoom;
  const x2 = (b.x + b.width/2 - r.left) / zoom;
  const y2 = (b.y + b.height/2 - r.top) / zoom;
  const offset = Math.max(40, Math.abs(x2 - x1) * .5);
  const d1 = from.classList.contains("out") ? 1 : -1;
  const d2 = to.classList.contains("out") ? 1 : -1;
  p.setAttribute("d", `M${x1},${y1} C${x1+offset*d1},${y1} ${x2+offset*d2},${y2} ${x2},${y2}`);
}

/* ---- Selection helpers ---- */
function selectNode(n){
  clearSelection();
  n.classList.add("selected");
  selectedNode = n;
  selectedNodes.clear();
  selectedNodes.add(n);
}
function selectLink(l){
  clearSelection();
  l.path.classList.add("selected");
  selectedLink = l;
}
function clearSelection(){
  realNodes().forEach(n=>{ n.classList.remove("selected","multi-selected"); });
  document.querySelectorAll(".link").forEach(l=> l.classList.remove("selected"));
  selectedNode = null; selectedLink = null; selectedNodes.clear();
}
function addToSelection(n){
  selectedNodes.add(n);
  n.classList.add("multi-selected");
  updateLinkSelection();
}
function removeFromSelection(n){
  selectedNodes.delete(n);
  n.classList.remove("multi-selected");
  updateLinkSelection();
}
function updateLinkSelection(){
  links.forEach(l=>{
    const fromNode = l.from.parentElement;
    const toNode = l.to.parentElement;
    if(selectedNodes.has(fromNode) && selectedNodes.has(toNode)) l.path.classList.add("selected");
    else l.path.classList.remove("selected");
  });
}
function snapToGridCoord(val){
  return snapToGrid ? Math.round(val/gridSize)*gridSize : Math.round(val);
}

/* ---- Mouse down on viewport starts selection box ---- */
viewport.addEventListener("mousedown", e=>{
  if(pasteMode) return;
  if(!e.target.closest(".node") && !e.target.closest("path") && !e.target.classList.contains("port")){
    if(!e.ctrlKey && !e.metaKey && !e.shiftKey) clearSelection();
    const r = viewport.getBoundingClientRect();
    selectStartX = (e.clientX - r.left) / zoom;
    selectStartY = (e.clientY - r.top) / zoom;
    dragSelect = true;
    selectionBox.style.left = selectStartX + "px";
    selectionBox.style.top = selectStartY + "px";
    selectionBox.style.width = "0";
    selectionBox.style.height = "0";
    selectionBox.style.display = "block";
  }
});

/* ---- Keyboard handlers (delete/copy/cut/paste/undo shortcuts) ---- */
document.addEventListener("keydown", e=>{
  // Alt+1 => zoom origin to 1
  if(e.altKey && !e.ctrlKey && !e.metaKey && e.key === "1"){
    e.preventDefault();
    applyZoom(1);
    return;
  }
  // Alt+G => toggle grid on/off
  if(e.altKey && !e.ctrlKey && !e.metaKey && (e.key === "g" || e.key === "G")){
    e.preventDefault();
    snapToGrid = !snapToGrid;
    gridSnapCheckbox.checked = snapToGrid;
    // show/hide background grid in viewport for visual feedback
    if(viewport.classList.contains('grid-off')) viewport.classList.remove('grid-off');
    if(!snapToGrid) viewport.classList.add('grid-off');
    appendLog('system', 'Grid snap ' + (snapToGrid ? 'enabled' : 'disabled'));
    return;
  }

  // Intercept undo and delay slightly if a paste just finished (to avoid race)
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z"){
    e.preventDefault();
    if(e.shiftKey){
      redo();
    } else {
      const now = Date.now();
      if(pasteCompletedAt && (now - pasteCompletedAt) < 300){
        setTimeout(()=>{ undo(); }, 50);
      } else {
        undo();
      }
    }
    return;
  }
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y"){
    e.preventDefault();
    redo();
    return;
  }

  if(e.key === "Delete"){
    if(selectedNodes.size > 0){
      selectedNodes.forEach(n=>{
        links = links.filter(l=>{
          const shouldRemove = l.from.parentElement === n || l.to.parentElement === n;
          if(shouldRemove){ l.path?.remove(); l.hit?.remove(); }
          return !shouldRemove;
        });
        n.remove();
      });
      selectedNodes.clear();
      selectedNode = null;
      redrawLinks();
      pushState();
    } else if(selectedNode){
      links = links.filter(l=> l.from.parentElement !== selectedNode && l.to.parentElement !== selectedNode);
      selectedNode.remove();
      selectedNode = null;
      redrawLinks();
      pushState();
    }
    if(selectedLink){
      selectedLink.path.remove();
      selectedLink.hit.remove();
      links = links.filter(l=> l !== selectedLink);
      selectedLink = null;
      pushState();
    }
  }

  // Copy
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "c" && selectedNodes.size > 0){
    e.preventDefault();
    copySelection();
  }

  // Cut
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "x" && selectedNodes.size > 0){
    e.preventDefault();
    copySelection();
    selectedNodes.forEach(n=>{
      links = links.filter(l=>{
        const shouldRemove = l.from.parentElement === n || l.to.parentElement === n;
        if(shouldRemove){ l.path?.remove(); l.hit?.remove(); }
        return !shouldRemove;
      });
      n.remove();
    });
    selectedNodes.clear();
    selectedNode = null;
    redrawLinks();
    pushState();
  }

  // Paste (enter paste mode)
  if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "v" && clipboard){
    e.preventDefault();
    pasteMode = true;
    viewport.style.cursor = "crosshair";
    pastePreview.style.display = "block";
  }

  if(e.key === "Escape" && pasteMode){
    pasteMode = false;
    viewport.style.cursor = "";
    pastePreview.style.display = "none";
    pastePreview.innerHTML = "";
  }

});

/* ---- Copy / Paste implementation (non-colliding IDs + preview) ---- */
/* (unchanged from previous behavior) */
function copySelection(){
  const nodes = [];
  const originalToTemp = new Map();
  let tempCounter = 0;
  let minCenterX = Infinity, minCenterY = Infinity, maxCenterX = -Infinity, maxCenterY = -Infinity;

  console.log('[copySelection] start - selectedNodes.size:', selectedNodes.size);
  let iterCount = 0;
  
  selectedNodes.forEach(n=>{
    iterCount++;
    console.log(`[copySelection] iteration ${iterCount}:`, {
      id: n.dataset.id,
      type: n.dataset.type,
      hasInst: !!n.querySelector('.instruction'),
      hasArgs: !!n.querySelector('.args')
    });
    
    const x = parseInt(n.style.left) || 0;
    const y = parseInt(n.style.top) || 0;
    const nodeWidth = 150;
    const nodeHeight = n.offsetHeight || getNodeHeight(n.dataset.type);
    const centerX = x + nodeWidth/2;
    const centerY = y + nodeHeight/2;
    minCenterX = Math.min(minCenterX, centerX);
    minCenterY = Math.min(minCenterY, centerY);
    maxCenterX = Math.max(maxCenterX, centerX);
    maxCenterY = Math.max(maxCenterY, centerY);

    tempCounter++;
    const tempId = 'c' + tempCounter;
    originalToTemp.set(String(n.dataset.id), tempId);

    // capture additional fields (setpoint/instruction/args) so INS nodes are preserved
    const setpointEl = n.querySelector('.setpoint');
    const instEl = n.querySelector('.instruction');
    const argsEl = n.querySelector('.args');
    const instIsPlaceholder = instEl ? instEl.classList.contains('placeholder') : true;
    const argsIsPlaceholder = argsEl ? argsEl.classList.contains('placeholder') : true;
    nodes.push({
      id: tempId,
      origId: String(n.dataset.id),
      type: String(n.dataset.type || "open"),
      centerX, centerY,
      addr: (n.querySelector(".addr") ? n.querySelector(".addr").textContent : "Address"),
      addrPlaceholder: (n.querySelector(".addr") ? n.querySelector(".addr").classList.contains("placeholder") : true),
      tag: (n.querySelector(".tag") ? n.querySelector(".tag").textContent : "Tag"),
      tagPlaceholder: (n.querySelector(".tag") ? n.querySelector(".tag").classList.contains("placeholder") : true),
      setpoint: setpointEl ? setpointEl.textContent : null,
      instruction: instEl ? (instIsPlaceholder ? "" : instEl.textContent.trim()) : "",
      instructionPlaceholder: instIsPlaceholder,
      args: argsEl ? (argsIsPlaceholder ? "" : argsEl.textContent.trim()) : "",
      argsPlaceholder: argsIsPlaceholder
    });
  });

  const copiedLinks = [];
  links.forEach(l=>{
    const fromNode = l.from.parentElement;
    const toNode = l.to.parentElement;
    const fromOrig = String(fromNode.dataset.id);
    const toOrig = String(toNode.dataset.id);
    const fromTemp = originalToTemp.get(fromOrig);
    const toTemp = originalToTemp.get(toOrig);
    if(fromTemp && toTemp){
      copiedLinks.push({
        from: fromTemp,
        fromPort: l.from.classList.contains("out") ? "out" : "in",
        to: toTemp,
        toPort: l.to.classList.contains("out") ? "out" : "in"
      });
    }
  });
  const centerX = (minCenterX + maxCenterX) / 2;
  const centerY = (minCenterY + maxCenterY) / 2;
  clipboard = { nodes, links: copiedLinks, centerX, centerY };
  console.log('[copySelection] copied', nodes.length, 'nodes, links:', copiedLinks.length);
}

/* Show preview of palette drag while dragging from palette */
function updatePaletteDragPreview(type, centerX, centerY){
  pastePreview.style.display = "block";
  pastePreview.innerHTML = "";
  const previewNode = document.createElement("div");
  previewNode.className = "node";
  
  // 중심점을 기준으로 좌상단 좌표 계산
  const nodeHeight = getNodeHeight(type);
  const nodeWidth = 150;
  const leftPos = centerX - nodeWidth / 2;
  const topPos = centerY - nodeHeight / 2;
  
  previewNode.style.left = leftPos + "px";
  previewNode.style.top = topPos + "px";
  previewNode.style.position = "absolute";
  previewNode.style.opacity = "0.6";
  previewNode.style.pointerEvents = "none";
  previewNode.style.border = "2px solid #fb923c";

  const symbols = {open:"[ ]",close:"[/]",rising:"[↑]",falling:"[↓]",invert:"[NOT]",coil:"( )",set:"(S)",reset:"(R)",ton:"[TON]",toff:"[TOFF]",tp:"[TP]",ctu:"[CTU]",ctd:"[CTD]",move:"[MOVE]",add:"[ADD]",sub:"[SUB]",mul:"[MUL]",div:"[DIV]",mod:"[MOD]",shl:"[SHL]",shr:"[SHR]",rol:"[ROL]",ror:"[ROR]",and:"[AND]",or:"[OR]",xor:"[XOR]",not:"[NOT]",eq:"[EQ]",gt:"[GT]",ge:"[GE]",lt:"[LT]",le:"[LE]",ne:"[NE]",instruction:"[INS]",network:"[NET]"};
  
  const sym = document.createElement("div");
  sym.className = "symbol";
  sym.textContent = symbols[type] || symbols["open"];
  
  const addr = document.createElement("div");
  addr.className = "addr placeholder";
  addr.textContent = "Address";
  
  const tag = document.createElement("div");
  tag.className = "tag placeholder";
  tag.textContent = "Tag";
  
  const pi = document.createElement("div");
  const po = document.createElement("div");
  pi.className = "port in";
  po.className = "port out";

  const elements = [sym];
  
  // INS nodes don't have addr field
  if(type !== "instruction"){
    elements.push(addr);
  }
  
  // Add instruction/args fields for INS nodes
  if(type === "instruction"){
    const inst = document.createElement("div");
    inst.className = "instruction placeholder";
    inst.textContent = "Instruction";
    
    const args = document.createElement("div");
    args.className = "args placeholder";
    args.textContent = "Args";
    
    elements.push(inst, args, tag);
  } else {
    elements.push(tag);
  }
  
  elements.push(pi, po);
  previewNode.append(...elements);
  pastePreview.appendChild(previewNode);
}

/* Show preview of clipboard while in pasteMode */
function updatePastePreview(x, y){
  if(!clipboard) return;
  pastePreview.innerHTML = "";
  const previewSvg = document.createElementNS("http://www.w3.org/2000/svg","svg");
  previewSvg.style.position = "absolute";
  previewSvg.style.width = "100%";
  previewSvg.style.height = "100%";
  previewSvg.style.pointerEvents = "none";

  const previewNodes = new Map();

  clipboard.nodes.forEach(n=>{
    // n.centerX/centerY are absolute centers from copy time
    const newCenterX = x - clipboard.centerX + n.centerX;
    const newCenterY = y - clipboard.centerY + n.centerY;
    const nodeWidth = 150;
    const nodeHeight = getNodeHeight(n.type);
    const left = newCenterX - nodeWidth/2;
    const top = newCenterY - nodeHeight/2;

    const previewNode = document.createElement("div");
    previewNode.className = "node";
    previewNode.style.left = left + "px";
    previewNode.style.top = top + "px";
    previewNode.style.opacity = "0.6";

    const symbols = {open:"[ ]",close:"[/]",rising:"[↑]",falling:"[↓]",invert:"[NOT]",coil:"( )",set:"(S)",reset:"(R)",ton:"[TON]",toff:"[TOFF]",tp:"[TP]",ctu:"[CTU]",ctd:"[CTD]",move:"[MOVE]",add:"[ADD]",sub:"[SUB]",mul:"[MUL]",div:"[DIV]",mod:"[MOD]",shl:"[SHL]",shr:"[SHR]",rol:"[ROL]",ror:"[ROR]",and:"[AND]",or:"[OR]",xor:"[XOR]",not:"[NOT]",eq:"[EQ]",gt:"[GT]",ge:"[GE]",lt:"[LT]",le:"[LE]",ne:"[NE]",instruction:"[INS]"};
   const fieldConfigs = {
     ton: [{ name: "addr", placeholder: "Timer Name" }, { name: "tag", placeholder: "Tag" }, { name: "setpoint", placeholder: "Setpoint" }],
     toff: [{ name: "addr", placeholder: "Timer Name" }, { name: "tag", placeholder: "Tag" }, { name: "setpoint", placeholder: "Setpoint" }],
     tp: [{ name: "addr", placeholder: "Timer Name" }, { name: "tag", placeholder: "Tag" }, { name: "setpoint", placeholder: "Setpoint" }],
     ctu: [{ name: "addr", placeholder: "Counter Name" }, { name: "tag", placeholder: "Tag" }, { name: "setpoint", placeholder: "Preset" }],
     ctd: [{ name: "addr", placeholder: "Counter Name" }, { name: "tag", placeholder: "Tag" }, { name: "setpoint", placeholder: "Preset" }],
     move: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input" }, { name: "output", placeholder: "Output" }],
     add: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }, { name: "output", placeholder: "Output" }],
     sub: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }, { name: "output", placeholder: "Output" }],
     mul: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }, { name: "output", placeholder: "Output" }],
     div: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }, { name: "output", placeholder: "Output" }],
     mod: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }, { name: "output", placeholder: "Output" }],
     and: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }, { name: "output", placeholder: "Output" }],
     or: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }, { name: "output", placeholder: "Output" }],
     xor: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }, { name: "output", placeholder: "Output" }],
     not: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input" }, { name: "output", placeholder: "Output" }],
     shl: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input" }, { name: "output", placeholder: "Output" }],
     shr: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input" }, { name: "output", placeholder: "Output" }],
     rol: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input" }, { name: "output", placeholder: "Output" }],
     ror: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input" }, { name: "output", placeholder: "Output" }],
     eq: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }],
     gt: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }],
     ge: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }],
     lt: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }],
     le: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }],
     ne: [{ name: "addr", placeholder: "Address" }, { name: "tag", placeholder: "Tag" }, { name: "input1", placeholder: "Input1" }, { name: "input2", placeholder: "Input2" }]
  };
  const sym = document.createElement("div");
  sym.className = "symbol";
  sym.textContent = symbols[n.type] || symbols["open"];
  const addr = document.createElement("div");
  addr.className = "addr";
  addr.textContent = (n.addrPlaceholder ? "Address" : n.addr);
  if(n.addrPlaceholder) addr.classList.add("placeholder");
  const tag = document.createElement("div");
  tag.className = "tag";
  tag.textContent = (n.tagPlaceholder ? "Tag" : n.tag);
  if(n.tagPlaceholder) tag.classList.add("placeholder");
  const pi = document.createElement("div");
  const po = document.createElement("div");
  pi.className = "port in";
  po.className = "port out";

  const elements = [sym];
  
  // INS nodes don't have addr field
  if(n.type !== "instruction"){
    elements.push(addr);
  }
  
  // Add instruction/args fields for INS nodes in preview
  if(n.type === "instruction"){
    const inst = document.createElement("div");
    inst.className = "instruction";
    inst.textContent = (n.instructionPlaceholder ? "Instruction" : n.instruction);
    if(n.instructionPlaceholder) inst.classList.add("placeholder");
    
    const args = document.createElement("div");
    args.className = "args";
    args.textContent = (n.argsPlaceholder ? "Args" : n.args);
    if(n.argsPlaceholder) args.classList.add("placeholder");
    
    elements.push(inst, args, tag);
  } else {
    elements.push(tag);
  }
  
  elements.push(pi, po);
  previewNode.append(...elements);
    pastePreview.appendChild(previewNode);
    previewNodes.set(n.id, { node: previewNode, centerX: newCenterX, centerY: newCenterY });
  });

  clipboard.links.forEach(l=>{
    const fromData = previewNodes.get(l.from);
    const toData = previewNodes.get(l.to);
    if(fromData && toData){
      const path = document.createElementNS("http://www.w3.org/2000/svg","path");
      path.classList.add("link");
      path.style.opacity = "0.5";
      const nodeWidth = 150;
      const fromX = fromData.centerX + (l.fromPort === "out" ? nodeWidth/2 : -nodeWidth/2);
      const fromY = fromData.centerY - (getNodeHeight(clipboard.nodes.find(n=>n.id===l.from)?.type||'open')/2) + 40;
      const toX = toData.centerX + (l.toPort === "out" ? nodeWidth/2 : -nodeWidth/2);
      const toY = toData.centerY - (getNodeHeight(clipboard.nodes.find(n=>n.id===l.to)?.type||'open')/2) + 40;
      const offset = Math.max(40, Math.abs(toX - fromX) * .5);
      const d1 = l.fromPort === "out" ? 1 : -1;
      const d2 = l.toPort === "out" ? 1 : -1;
      path.setAttribute("d", `M${fromX},${fromY} C${fromX+offset*d1},${fromY} ${toX+offset*d2},${toY} ${toX},${toY}`);
      previewSvg.appendChild(path);
    }
  });

  pastePreview.appendChild(previewSvg);
}

/* Paste clipboard into the viewport (create new nodes + links) */
function pasteSelection(x, y){
  if(!clipboard) return;

  // push pre-paste snapshot to ensure deterministic undo
  const before = snapshot();
  undoStack.push(before);
  if(undoStack.length > 80) undoStack.shift();
  redoStack = [];

  const idMap = new Map();
  const newNodes = [];

  clipboard.nodes.forEach(n=>{
    nodeId = Number(nodeId) + 1;
    const newId = String(nodeId);
    idMap.set(n.id, newId);
    // Use center-based coordinates stored in clipboard
    const nodeWidth = 150;
    const nodeHeight = getNodeHeight(n.type);
    const newCenterX = snapToGridCoord(x - clipboard.centerX + n.centerX);
    const newCenterY = snapToGridCoord(y - clipboard.centerY + n.centerY);
    const created = createNode(
      n.type,
      newCenterX,
      newCenterY,
      newId,
      (n.addrPlaceholder ? null : n.addr),
      (n.tagPlaceholder ? null : n.tag),
      n.setpoint || null,
      true,
      (n.instructionPlaceholder ? null : (n.instruction || "")),
      (n.argsPlaceholder ? null : (n.args || ""))
    );
    if(created){
      const addrEl = created.querySelector(".addr");
      const tagEl = created.querySelector(".tag");
      if(addrEl){
        if(n.addrPlaceholder) addrEl.classList.add("placeholder"); else addrEl.classList.remove("placeholder");
      }
      if(tagEl){
        if(n.tagPlaceholder) tagEl.classList.add("placeholder"); else tagEl.classList.remove("placeholder");
      }
    }
    newNodes.push(created);
  });

  clipboard.links.forEach(l=>{
    const fromId = idMap.get(l.from);
    const toId = idMap.get(l.to);
    const fromNode = document.querySelector(`.node[data-id="${fromId}"]`);
    const toNode = document.querySelector(`.node[data-id="${toId}"]`);
    if(fromNode && toNode){
      const fromPort = fromNode.querySelector(`.port.${l.fromPort}`);
      const toPort = toNode.querySelector(`.port.${l.toPort}`);
      if(fromPort && toPort) finalizeLink(fromPort, toPort);
    }
  });

  clearSelection();
  newNodes.forEach(n=>{ if(n) addToSelection(n); });
  console.log('[pasteSelection] pasted', newNodes.length, 'nodes');

  // record post-paste snapshot
  pushState();

  // mark paste completion time
  pasteCompletedAt = Date.now();
  
  // ensure pasteMode is cleared and preview cleaned up
  pasteMode = false;
  viewport.style.cursor = "";
  pastePreview.style.display = "none";
  pastePreview.innerHTML = "";
}

/* clicking viewport while in paste mode performs the paste */
viewport.addEventListener("click", e=>{
  if(pasteMode){
    const r = viewport.getBoundingClientRect();
    const x = (e.clientX - r.left) / zoom;
    const y = (e.clientY - r.top) / zoom;
    console.log('[viewport.click] paste at', {x, y}, 'clipboard nodes:', clipboard?.nodes?.length);
    pasteSelection(snapToGridCoord(x), snapToGridCoord(y));
  }
});

/* ---- Deploy / Import / Export / Verify ---- */
/* Helper: Check for unanchored nodes and highlight them in red */
function validateNetworkAnchors() {
  const json = snapshot();
  const data = JSON.parse(json);
  const networkNodes = data.nodes.filter(n => n.type === 'network');
  const allNodes = data.nodes;
  const links = data.linkData || [];

  // Build undirected adjacency map from linkData
  const adj = {};
  links.forEach(l => {
    const f = String(l.from);
    const t = String(l.to);
    adj[f] = adj[f] || new Set();
    adj[t] = adj[t] || new Set();
    adj[f].add(t);
    adj[t].add(f);
  });

  // Find all nodes connected to network nodes (anchored nodes) using undirected BFS
  const anchoredNodeIds = new Set();
  networkNodes.forEach(netNode => {
    const start = String(netNode.id);
    anchoredNodeIds.add(start);
    const visited = new Set([start]);
    const queue = [start];
    while (queue.length > 0) {
      const currentId = queue.shift();
      const neighbors = adj[currentId] ? Array.from(adj[currentId]) : [];
      neighbors.forEach(nb => {
        if (!visited.has(nb)) {
          visited.add(nb);
          anchoredNodeIds.add(nb);
          queue.push(nb);
        }
      });
    }
  });

  // Find unanchored nodes (exclude network nodes themselves)
  const unanchoredNodes = allNodes.filter(n => !anchoredNodeIds.has(String(n.id)) && n.type !== 'network');
  
  if (unanchoredNodes.length > 0) {
    // Highlight unanchored nodes and their links in red
    unanchoredNodes.forEach(unNode => {
      const domNode = document.querySelector(`.node[data-id="${unNode.id}"]`);
      if (domNode) {
        domNode.style.borderColor = '#ef4444';
        domNode.style.borderWidth = '3px';
        domNode.style.backgroundColor = '#fee2e2';
        domNode.classList.add('validation-error');
      }
    });
    
    // Highlight links connected to unanchored nodes in red
    links.forEach(link => {
      if (unanchoredNodes.some(n => n.id === link.from) || unanchoredNodes.some(n => n.id === link.to)) {
        // Find and highlight the link
        const fromNode = document.querySelector(`.node[data-id="${link.from}"]`);
        const toNode = document.querySelector(`.node[data-id="${link.to}"]`);
        if (fromNode && toNode) {
          const fromPort = link.fromPort === 'out' ? fromNode.querySelector('.port.out') : fromNode.querySelector('.port.in');
          const toPort = link.toPort === 'out' ? toNode.querySelector('.port.out') : toNode.querySelector('.port.in');
          if (fromPort && toPort) {
            // Find the link path and highlight it
            svg.querySelectorAll('path').forEach(path => {
              if (path.dataset.linkFrom === link.from.toString() && path.dataset.linkTo === link.to.toString()) {
                path.style.stroke = '#ef4444';
                path.style.strokeWidth = '4';
                const hitPath = path.nextElementSibling;
                if (hitPath && hitPath.classList.contains('link-hit')) {
                  hitPath.style.stroke = '#ef4444';
                  hitPath.style.strokeWidth = '6';
                }
              }
            });
          }
        }
      }
    });
    
    // Log detailed error
    const nodeList = unanchoredNodes.map(n => ({ id: n.id, type: n.type, addr: n.addr }));
    // concise message for alert (limit list length)
    const ids = unanchoredNodes.map(n => n.id);
    const idsPreview = ids.slice(0, 10).join(', ') + (ids.length > 10 ? ', ...' : '');
    const alertMsg = `앵커 없는 노드 감지: ${unanchoredNodes.length}개\nIDs: ${idsPreview}\n편집기를 확인하세요.`;
    alert(alertMsg);
    emitValidationError('unanchored-nodes', `❌ 앵커 없는 노드 감지: ${unanchoredNodes.length}개`, { nodes: nodeList });
    emitValidationError('unanchored-nodes-summary', `⚠️ Network 노드에 연결되지 않은 노드 ${unanchoredNodes.length}개가 있습니다. 빨간색으로 표시됨.`, { count: unanchoredNodes.length });
    return false;
  }
  
  appendLog('system', `✓ 모든 노드가 Network 앵커에 연결되어 있습니다`);
  return true;
}

/* Helper: Clear validation error highlighting */
function clearValidationHighlights() {
  realNodes().forEach(n => {
    n.style.borderColor = '';
    n.style.borderWidth = '';
    n.style.backgroundColor = '';
    n.classList.remove('validation-error');
  });
  svg.querySelectorAll('path').forEach(path => {
    path.style.stroke = '';
    path.style.strokeWidth = '';
    const hitPath = path.nextElementSibling;
    if (hitPath && hitPath.classList.contains('link-hit')) {
      hitPath.style.stroke = '';
      hitPath.style.strokeWidth = '';
    }
  });
}

/* ---- Emit validation error as both log and DOM event ---- */
function emitValidationError(code, message, details = {}){
  try{
    appendLog('error', message);
  }catch(e){}
  try{
    const ev = new CustomEvent('plc-validation-error', { detail: Object.assign({ code: String(code), message: String(message) }, details) });
    window.dispatchEvent(ev);
  }catch(e){ console.warn('Failed to dispatch plc-validation-error', e); }
}

function assignNetworkIds() {
  // Get current snapshot data
  const json = snapshot();
  const data = JSON.parse(json);
  const nodes = data.nodes;
  const links = data.linkData;
  
  // Find all network nodes (they should have addr like N0, N1, etc.)
  const networkNodes = nodes.filter(n => n.type === 'network');
  
  // Create mapping from node id to network address
  const nodeToNetworkAddr = {};
  
  // BFS from each network node to assign network address
  networkNodes.forEach((netNode) => {
    const networkAddr = netNode.addr && netNode.addr.trim() ? netNode.addr.trim() : null;
    if (!networkAddr) return; // Skip if network node has no address
    
    const visited = new Set();
    const queue = [netNode.id];
    visited.add(netNode.id);
    nodeToNetworkAddr[netNode.id] = networkAddr;
    
    // BFS to find all connected nodes
    while (queue.length > 0) {
      const currentId = queue.shift();
      
      // Find all nodes connected FROM currentId
      links.forEach(link => {
        if (link.from === currentId && !visited.has(link.to)) {
          visited.add(link.to);
          nodeToNetworkAddr[link.to] = networkAddr;
          queue.push(link.to);
        }
      });
    }
  });
  
  // Apply network addresses to DOM nodes
  realNodes().forEach(domNode => {
    const nodeId = Number(domNode.dataset.id);
    const networkAddr = nodeToNetworkAddr[nodeId] || '';
    domNode.dataset.networkId = networkAddr; // Store network address as networkId
  });
  
  console.log('Network addresses assigned:', nodeToNetworkAddr);
  appendLog('system', `Network addresses assigned: ${JSON.stringify(nodeToNetworkAddr)}`);
}

// Validation: Check for duplicate network addresses
function validateNetworkNoDuplicates() {
  const json = snapshot();
  const data = JSON.parse(json);
  const networkNodes = data.nodes.filter(n => n.type === 'network');
  
  const networkAddrs = {};
  for (const netNode of networkNodes) {
    const addr = netNode.addr && netNode.addr.trim() ? netNode.addr.trim() : '';
    if (!addr) {
      const msg = `Network 노드 ID=${netNode.id}에 주소가 없습니다 (N0-N99 형식으로 입력하세요)`;
      alert(msg);
      emitValidationError('network-no-address', `❌ ${msg}`, { nodeId: netNode.id });
      return false;
    }
    if (networkAddrs[addr]) {
      const msg = `네트워크 주소 "${addr}"가 중복됩니다. 배포 불가.`;
      alert(msg);
      emitValidationError('network-duplicate', `❌ ${msg}`, { addr, firstNodeId: networkAddrs[addr], nodeId: netNode.id });
      return false;
    }
    networkAddrs[addr] = netNode.id;
  }
  
  appendLog('system', `✓ 네트워크 중복 검사 완료: ${Object.keys(networkAddrs).join(', ')}`);
  return true;
}

// Validation: Check for duplicate coils (same address in multiple coil nodes)
// M 영역(M0, M1, ...)의 이중 코일은 허용 (set/reset 조합 가능)
function validateNoDoubleCoils() {
  const json = snapshot();
  const data = JSON.parse(json);
  const coilNodes = data.nodes.filter(n => n.type === 'coil' || n.type === 'set' || n.type === 'reset');
  
  const coilAddrs = {};
  for (const coilNode of coilNodes) {
    const addr = coilNode.addr && coilNode.addr.trim() ? coilNode.addr.trim() : '';
    if (!addr) {
      const msg = `Coil/Set/Reset 노드 ID=${coilNode.id}에 주소가 없습니다`;
      alert(msg);
      emitValidationError('coil-no-address', `❌ ${msg}`, { nodeId: coilNode.id });
      return false;
    }
    
    // M 영역(M0, M1, ...) 이중 코일 허용
    const isMAddr = /^M\d+$/i.test(addr);
    
    if (coilAddrs[addr]) {
      // M 영역이면 허용 (set/reset 조합 가능)
      if (!isMAddr) {
        const firstType = coilAddrs[addr].type;
        const msg = `이중 Coil 감지: 주소 "${addr}"가 노드 ${coilAddrs[addr].id}(${firstType})와 노드 ${coilNode.id}(${coilNode.type})에 모두 연결됨. 배포 불가.`;
        alert(msg);
        emitValidationError('double-coil', `❌ ${msg}`, { addr, firstNode: coilAddrs[addr], node: coilNode });
        return false;
      }
      // M 영역: 기존 노드 목록에 추가 (이중 허용)
      if (!Array.isArray(coilAddrs[addr])) {
        coilAddrs[addr] = [coilAddrs[addr]];
      }
      coilAddrs[addr].push(coilNode);
    } else {
      coilAddrs[addr] = coilNode;
    }
  }
  
  appendLog('system', `✓ 이중 Coil 검사 완료: ${Object.keys(coilAddrs).length}개 Coil 확인됨 (M 영역 이중 허용)`);
  return true;
}

// Validation: Check for duplicate timers and counters (same name in multiple instruction nodes)
function validateNoDoubleTimersCounters() {
  const json = snapshot();
  const data = JSON.parse(json);
  const instrNodes = data.nodes.filter(n => n.type === 'instruction');
  
  const timerAddrs = {};
  const counterAddrs = {};
  
  for (const instrNode of instrNodes) {
    const instruction = instrNode.instruction && instrNode.instruction.trim() ? instrNode.instruction.trim().toUpperCase() : '';
    const args = instrNode.args && instrNode.args.trim() ? instrNode.args.trim() : '';
    
    if (!args) continue;
    
    // Parse timer/counter name from args (format: "T1:1000" or "C1:100")
    const colonIndex = args.indexOf(':');
    const name = colonIndex > 0 ? args.substring(0, colonIndex).trim() : args.trim();
    
    if (instruction === 'TON' || instruction === 'TOFF' || instruction === 'TP') {
      if (timerAddrs[name]) {
        const firstInstr = timerAddrs[name].instruction;
        const msg = `이중 Timer 감지: "${name}"이 노드 ${timerAddrs[name].id}(${firstInstr})와 노드 ${instrNode.id}(${instruction})에 모두 존재. 배포 불가.`;
        alert(msg);
        appendLog('error', `❌ ${msg}`);
        return false;
      }
      timerAddrs[name] = instrNode;
    } else if (instruction === 'CTU' || instruction === 'CTD') {
      if (counterAddrs[name]) {
        const firstInstr = counterAddrs[name].instruction;
        const msg = `이중 Counter 감지: "${name}"이 노드 ${counterAddrs[name].id}(${firstInstr})와 노드 ${instrNode.id}(${instruction})에 모두 존재. 배포 불가.`;
        alert(msg);
        appendLog('error', `❌ ${msg}`);
        return false;
      }
      counterAddrs[name] = instrNode;
    }
  }
  
  const timerCount = Object.keys(timerAddrs).length;
  const counterCount = Object.keys(counterAddrs).length;
  if (timerCount > 0 || counterCount > 0) {
    appendLog('system', `✓ Timer/Counter 검사 완료: Timer ${timerCount}개, Counter ${counterCount}개 확인됨`);
  }
  return true;
}

deployBtn.addEventListener("click", async ()=>{
  // Clear previous validation highlights
  clearValidationHighlights();
  
  // Step 1: Validate anchors (check unanchored nodes)
  if (!validateNetworkAnchors()) return;
  
  // Step 2: Assign network addresses
  assignNetworkIds();
  
  // Step 3: Validate network addresses (no duplicates)
  if (!validateNetworkNoDuplicates()) return;
  
  // Step 4: Validate no double coils
  if (!validateNoDoubleCoils()) return;
  
  // Step 5: Validate no double timers/counters
  if (!validateNoDoubleTimersCounters()) return;
  
  // Step 6: Send snapshot
  const json = snapshot();
  try{
    const res = await fetch(`http://${serverHost}/save`, { method: "POST", headers: {"Content-Type":"application/x-www-form-urlencoded"}, body: "logic=" + encodeURIComponent(json) });
    if(res.ok) {
      alert("PLC 저장 및 실행 요청 완료.");
      appendLog('system','Deployed logic to device.');
      setModified(false); // clear modified marker on successful deploy
        // Initialize debug console memory monitor after successful deploy
        try{
          // Clear UI logs and memory cache
          clearLogs();
          lastMemory = {};
          // Refresh memory and IO displays to show cleared state
          try{ updateMemoryList({}); }catch(e){}
          try{ updateIOList({}); }catch(e){}
          appendLog('system','Memory monitor initialized after deploy.');
          // Open debug sidebar for visibility
          try{ openSidebar(); }catch(e){}
          // Request an immediate memory snapshot from device via WebSocket if supported
          if(ws && ws.readyState === WebSocket.OPEN){
            try{ ws.send('MONITOR_INIT'); appendLog('debug','Requested memory snapshot via WebSocket (MONITOR_INIT)'); }catch(e){ appendLog('debug','WS monitor init send failed: '+(e.message||e)); }
          }
        }catch(e){ appendLog('debug','Init memory monitor failed: '+(e.message||e)); }
      // Restore previous PLC run/stop state after deploy
      try{
        const prevState = currentPlcStatus || null; // expected 'RUN' or 'STOP' (or null)
        if(prevState && ws && ws.readyState === WebSocket.OPEN){
          // Only send if previous state was RUN or STOP to restore
          if(prevState === 'RUN' || prevState === 'STOP'){
            ws.send(prevState);
            appendLog('system', `Restored PLC state after deploy: ${prevState}`);
          }
        } else {
          appendLog('system','WS not open or previous PLC state unknown: no state restore');
        }
      }catch(e){ appendLog('debug','Restore state after deploy failed: '+(e.message||e)); }
    }
    else {
      const text = await res.text().catch(()=>res.statusText);
      appendLog('error','Deploy failed: ' + res.status + ' ' + res.statusText + ' ' + text);
      // Try fallback: send logic JSON via WebSocket if available
      if(ws && ws.readyState === WebSocket.OPEN){
        try{
          ws.send(json);
          appendLog('system','Fallback: sent logic via WebSocket after HTTP save failed');
          alert('HTTP 저장 실패했지만 WebSocket으로 로직 전송을 시도했습니다. 장치에서 적용되었는지 확인하세요.');
          setModified(false);
        }catch(we){
          appendLog('error','Fallback WS send failed: ' + (we.message||we));
          alert(`저장 실패 ❌: ${res.status} ${res.statusText}\n${text}`);
        }
      } else {
        alert(`저장 실패 ❌: ${res.status} ${res.statusText}\n${text}`);
      }
    }
  } catch(e){
    appendLog('error','Deploy communication error: ' + (e.message||e));
    // Network-level fetch failure: attempt websocket fallback
    if(ws && ws.readyState === WebSocket.OPEN){
      try{
        ws.send(json);
        appendLog('system','Fallback: sent logic via WebSocket after HTTP fetch failed');
        alert('통신 오류 발생했지만 WebSocket으로 로직 전송을 시도했습니다. 장치에서 적용되었는지 확인하세요.');
        setModified(false);
      }catch(we){
        appendLog('error','Fallback WS send failed: ' + (we.message||we));
        alert("통신 오류: 저장 실패 ❌");
      }
    } else {
      alert("통신 오류: 저장 실패 ❌");
    }
  }
});

async function fetchAndApplyLogic(url, isVerify = false){
  try{
    // Support relative paths by prefixing device host when needed
    const fetchUrl = (typeof url === 'string' && url.startsWith('/')) ? `http://${serverHost}${url}` : url;
    const res = await fetch(fetchUrl);
    if(!res.ok) throw new Error("서버에서 로직을 불러오지 못했습니다.");
    const jsonText = await res.text();
    if(isVerify){
      const currentSnapshot = snapshot();
      // Parse and compare structurally to avoid differences due to whitespace/order
      function stableStringify(obj, skipFields = []){
        if(obj === null) return 'null';
        if(typeof obj !== 'object') return JSON.stringify(obj);
        if(Array.isArray(obj)) return '[' + obj.map(item => stableStringify(item, skipFields)).join(',') + ']';
        const keys = Object.keys(obj).sort().filter(k => !skipFields.includes(k));
        return '{' + keys.map(k => JSON.stringify(k) + ':' + stableStringify(obj[k], skipFields)).join(',') + '}';
      }
      try{
        const a = JSON.parse(currentSnapshot);
        const b = JSON.parse(jsonText);
        // Normalize nodes/linkData/nodeId to avoid differences caused by types or ordering
        function normalizeData(d){
          if(!d || typeof d !== 'object') return d;
          if(Array.isArray(d.nodes)){
            d.nodes = d.nodes.map(n => {
              // Normalize networkId to a canonical string: "N<index>" or "-1"
              let net = '-1';
              if (typeof n.networkId !== 'undefined' && n.networkId !== null && String(n.networkId).trim() !== '') {
                if (typeof n.networkId === 'number') {
                  net = (n.networkId >= 0) ? ('N' + String(n.networkId)) : '-1';
                } else {
                  const sRaw = String(n.networkId).trim();
                  if (sRaw === '-1') {
                    net = '-1';
                  } else {
                    const s = sRaw.toUpperCase();
                    if (s.startsWith('N')) {
                      net = s; // already "N0" style, keep it
                    } else if (!isNaN(Number(sRaw))) {
                      const num = Number(sRaw);
                      net = (num >= 0) ? ('N' + String(num)) : '-1';
                    } else {
                      net = sRaw; // keep raw string otherwise
                    }
                  }
                }
              }
              return {
                id: Number(n.id) || 0,
                networkId: net,
                x: Number(n.x) || 0,
                y: Number(n.y) || 0,
                type: (n.type || 'open'),
                addr: (n.addr || ''),
                tag: (n.tag || ''),
                setpoint: (n.setpoint == null) ? 0 : Number(n.setpoint) || 0,
                instruction: (n.instruction || ''),
                args: (n.args || '')
              };
            });
            d.nodes.sort((p,q)=>p.id - q.id);
          }
          if(Array.isArray(d.linkData)){
            d.linkData = d.linkData.map(l => ({ from: Number(l.from) || 0, to: Number(l.to) || 0 }));
            d.linkData.sort((p,q)=> (p.from - q.from) || (p.to - q.to));
          }
          d.nodeId = Number(d.nodeId) || 0;
          return d;
        }
        const na = normalizeData(a);
        const nb = normalizeData(b);
        if(stableStringify(na) === stableStringify(nb)){
          alert("✅ 로직이 ESP32에 저장된 내용과 일치합니다."); appendLog('system','Verify: matched');
        } else {
          // Debug helper: print normalized objects to console for quick diffing
          console.debug('Normalized Editor:', na);
          console.debug('Normalized Device: ', nb);
          alert("⚠️ 현재 편집기 로직과 ESP32 저장 로직이 다릅니다!"); appendLog('system','Verify: differs');
        }
      }catch(e){
        // fallback to string compare if parsing fails
        if(currentSnapshot === jsonText){ alert("✅ 로직이 ESP32에 저장된 내용과 일치합니다."); appendLog('system','Verify: matched'); }
        else { alert("⚠️ 현재 편집기 로직과 ESP32 저장 로직이 다릅니다!"); appendLog('system','Verify: differs'); }
      }
    } else {
      applySnapshot(jsonText);
      pushState(true); // loading from device => treat as pristine (not modified)
      alert("로직 불러오기 완료.");
      appendLog('system','Imported logic from device.');
      setModified(false);
    }
  } catch(e){
    appendLog('error','Fetch/import failed: ' + (e.message||e));
    alert("통신 오류: " + e.message);
  }
}

/* ---- Auto import logic from device on page load ---- */
async function autoLoadFromDevice(){
  try{
    const res = await fetch(`http://${serverHost}/load`);
    if(!res.ok) {
      console.log("No device logic or /load failed:", res.status);
      appendLog('system','Auto-load: no device logic');
      return;
    }
    const jsonText = await res.text();
    if(jsonText && jsonText.length > 5){
      try{
        applySnapshot(jsonText);
        pushState(true); // pristine
        setModified(false);
        console.log("장치에서 로직을 불러왔습니다.");
        appendLog('system','Auto-loaded logic from device.');
      }catch(e){
        console.error("applySnapshot failed:", e);
        appendLog('error','applySnapshot failed: ' + (e.message||e));
      }
    }
  }catch(e){
    console.warn("autoLoadFromDevice failed:", e);
    appendLog('error','Auto-load failed: ' + (e.message||e));
  }
}

/* ---- Zoom controls: buttons + Alt+wheel ---- */
function applyZoom(z){
  zoom = Math.max(0.5, Math.min(2, Number(z)));
  viewport.style.transform = `scale(${zoom})`;
  // 줌 레벨에 따라 그리드 크기 조정 (축소할 때 그리드가 더 커 보이도록)
  const gridSize = 40 / zoom;
  viewport.style.backgroundSize = `${gridSize}px ${gridSize}px`;
  // 줌아웃 시 스크롤바가 그리드 영역을 벗어나지 않게 overflow 조정
  flowWrapper.style.overflow = zoom < 1 ? 'hidden' : 'auto';
  redrawLinks();
}
zoomControls.addEventListener("click", e=>{
  const btn = e.target.closest("button");
  if(!btn) return;
  const z = btn.dataset.z;
  if(z === "1") applyZoom(1);
  else if(z === "+") applyZoom(zoom + 0.1);
  else if(z === "-") applyZoom(zoom - 0.1);
});
flowWrapper.addEventListener("wheel", e=>{
  if(!e.altKey) return;
  e.preventDefault();
  applyZoom(e.deltaY < 0 ? zoom + 0.1 : zoom - 0.1);
}, { passive:false });

/* ---- Init ---- */
pushState(true); // initial state: do not mark modified
initWebSocketClient();
autoLoadFromDevice();

  // Expose local helpers to window so other scripts and console can call them
  try{
    window.snapshot = snapshot;
    window.applySnapshot = applySnapshot;
    window.appendLog = appendLog;
    window.renderLogList = renderLogList;
    window.clearLogs = clearLogs;
  }catch(e){}

}); // DOMContentLoaded
</script>

<!-- WiFi Functions -->
<script>
// Resolve DOM elements locally and use relative endpoints to avoid scope issues
function updateWiFiStatus() {
  const wifiStatusEl = document.getElementById('wifi-status');
  fetch('/status')
    .then(r => r.json())
    .then(data => {
      if (data.wifi) {
        let html = `<div>AP : ${data.wifi.ap_ip}</div>`;
        if (data.wifi.sta_connected) {
          html += `<div style="margin-top:12px;">STA : ${data.wifi.sta_ip}</div><div>SSID : ${data.wifi.sta_ssid}</div><div>Signal: ${data.wifi.sta_rssi} dBm</div>`;
        } else {
          html += `<div style="margin-top:12px;">STA : Not connected</div>`;
        }
        if (wifiStatusEl) wifiStatusEl.innerHTML = html;

        // Show saved-credentials banner when device has saved creds but not connected
        try {
          const saved = !!data.wifi.saved;
          const banner = document.getElementById('wifi-saved-banner');
          if (banner) banner.style.display = (saved && !data.wifi.sta_connected) ? 'block' : 'none';
        } catch(e) { /* ignore */ }
      }
    })
    .catch(e => {
      if (wifiStatusEl) wifiStatusEl.textContent = 'Error loading status';
      appendLog('debug', 'WiFi status error: ' + (e.message || e));
    });
}

// WiFi 연결 성공 모달 표시
function showWiFiConnectedModal(ip, ssid) {
  const modal = document.getElementById('wifi-modal');
  const content = document.getElementById('wifi-modal-content');
  const btn = document.getElementById('wifi-modal-btn');
  
  if (content) {
    content.innerHTML = `<div style="font-size:14px;margin-bottom:8px;"><strong>${ssid}</strong></div><div>IP: ${ip}</div>`;
  }
  
  
  if (modal) {
    modal.style.display = 'flex';
  }
  
  if (btn) {
    btn.onclick = () => {
      if (modal) modal.style.display = 'none';
    };
  }
  
  // 3초 후 자동 닫기
  setTimeout(() => {
    if (modal) modal.style.display = 'none';
  }, 3000);
}

// Show save-filename modal and call callback(filename) on confirm
function showSaveFilenameModal(defaultName, callback) {
  const modal = document.getElementById('save-modal');
  const input = document.getElementById('save-filename-input');
  const ok = document.getElementById('save-filename-ok');
  const cancel = document.getElementById('save-filename-cancel');
  if (!modal || !input || !ok || !cancel) {
    if (typeof callback === 'function') callback(defaultName);
    return;
  }
  input.value = defaultName || 'plc_logic.json';
  modal.style.display = 'flex';

  function cleanup() {
    modal.style.display = 'none';
    ok.onclick = null; cancel.onclick = null;
  }

  ok.onclick = () => {
    let name = (input.value || '').trim();
    if (!name) name = defaultName || 'plc_logic.json';
    if (!/\.json$/i.test(name)) name += '.json';
    cleanup();
    if (typeof callback === 'function') callback(name);
  };
  cancel.onclick = () => { cleanup(); };

  setTimeout(()=>{ input.focus(); input.select(); }, 50);
}// Helper to perform scan/connect/disconnect and wire UI
document.addEventListener('DOMContentLoaded', () => {
  const wifiScanBtn = document.getElementById('wifi-scan-btn');
  const wifiConnectBtn = document.getElementById('wifi-connect-btn');
  const wifiDisconnectBtn = document.getElementById('wifi-disconnect-btn');
  const wifiSsidInput = document.getElementById('wifi-ssid-input');
  const wifiPasswordInput = document.getElementById('wifi-password-input');
  const wifiSaveCheckbox = document.getElementById('wifi-save-checkbox');
  const wifiSavedBanner = document.getElementById('wifi-saved-banner');
  const wifiAutoRetryBtn = document.getElementById('wifi-autoconnect-retry');
  const wifiForgetSavedBtn = document.getElementById('wifi-forget-saved');
  const wifiRetryInterval = document.getElementById('wifi-retry-interval');
  const wifiRetryAttempts = document.getElementById('wifi-retry-attempts');
  const wifiNetworks = document.getElementById('wifi-networks');

  if (wifiScanBtn) {
    wifiScanBtn.addEventListener('click', () => {
      wifiScanBtn.disabled = true; wifiScanBtn.textContent = 'Scanning...';
      if (wifiNetworks) wifiNetworks.innerHTML = '<div style="font-size:12px;color:#9aa3b2;">Scanning...</div>';
      
      fetch('/wifi/scan', { 
        method: 'GET',
        headers: { 'Cache-Control': 'no-cache', 'Pragma': 'no-cache' }
      })
        .then(r => {
          if (!r.ok) throw new Error(`HTTP ${r.status}`);
          return r.json();
        })
        .then(data => {
          if (data.error) {
            if (wifiNetworks) wifiNetworks.innerHTML = `<div style="font-size:12px;color:#ff6b6b;">Error: ${data.error}</div>`;
            appendLog('error', 'WiFi scan error: ' + data.error);
            return;
          }
          
          if (wifiNetworks) wifiNetworks.innerHTML = '';
          const list = data.networks || [];
          
          if (list.length) {
            list.forEach(net => {
              const div = document.createElement('div');
              div.style.cssText = 'padding:8px;background:rgba(255,255,255,0.02);border-radius:4px;cursor:pointer;border:1px solid #40506b;';
              const signalQuality = net.rssi > -50 ? '강함' : net.rssi > -70 ? '보통' : '약함';
              div.innerHTML = `<div style="font-size:12px;color:#fff;font-weight:600;">${net.ssid || '(hidden)'}</div><div style="font-size:11px;color:#9aa3b2;">Signal: ${net.rssi} dBm (${signalQuality}) ${net.secure ? '🔒' : ''}</div>`;
              div.addEventListener('click', () => {
                if (wifiSsidInput) wifiSsidInput.value = net.ssid;
                if (wifiPasswordInput) wifiPasswordInput.focus();
              });
              if (wifiNetworks) wifiNetworks.appendChild(div);
            });
          } else {
            if (wifiNetworks) wifiNetworks.innerHTML = '<div style="font-size:12px;color:#9aa3b2;">No networks found</div>';
							
          }
          appendLog('system', `Scanned ${list.length} networks`);
        })
        .catch(e => {
          if (wifiNetworks) wifiNetworks.innerHTML = `<div style="font-size:12px;color:#ff6b6b;">Scan failed: ${e.message || e}</div>`;
          appendLog('error', 'WiFi scan error: ' + (e.message || e));
          console.error('WiFi scan error:', e);
        })
        .finally(() => { wifiScanBtn.disabled = false; wifiScanBtn.textContent = 'Scan Networks'; });
    });
  }

  if (wifiConnectBtn) {
    wifiConnectBtn.addEventListener('click', () => {
      const ssid = (wifiSsidInput && wifiSsidInput.value.trim()) || '';
      const password = (wifiPasswordInput && wifiPasswordInput.value) || '';
      if (!ssid) { 
        alert('SSID를 입력하세요'); 
        return; 
      }
      wifiConnectBtn.disabled = true; 
      wifiConnectBtn.textContent = 'Connecting...';
      
      const params = new URLSearchParams(); 
      params.append('ssid', ssid); 
      params.append('password', password);
      // include save flag if checkbox present
      if (wifiSaveCheckbox) params.append('save', wifiSaveCheckbox.checked ? '1' : '0');
      
      fetch('/wifi/connect', { 
        method: 'POST', 
        body: params,
        headers: { 'Cache-Control': 'no-cache' }
      })
        .then(r => {
          if (!r.ok) throw new Error(`HTTP ${r.status}`);
          return r.json();
        })
        .then(data => {
          if (data.success) { 
            appendLog('system', `Connected! IP: ${data.ip}`); 
            showWiFiConnectedModal(data.ip, ssid);
            updateWiFiStatus(); 
            if (wifiSsidInput) wifiSsidInput.value=''; 
            if (wifiPasswordInput) wifiPasswordInput.value=''; 
          }
          else { 
            const errorMsg = data.error || 'Unknown error';
            appendLog('error', `Connection failed: ${errorMsg}`); 
            alert(`연결 실패: ${errorMsg}`); 
          }
        })
        .catch(e => { 
          appendLog('error', 'WiFi connect error: ' + (e.message || e)); 
          alert('연결 오류: ' + (e.message || e)); 
          console.error('WiFi connect error:', e);
        })
        .finally(() => { 
          wifiConnectBtn.disabled = false; 
          wifiConnectBtn.textContent = 'Connect'; 
          // refresh status and banner after connect attempt
          updateWiFiStatus();
        });
    });
  }

  // Auto-reconnect retry button (uses server-stored creds)
  if (wifiAutoRetryBtn) {
    wifiAutoRetryBtn.addEventListener('click', () => {
      wifiAutoRetryBtn.disabled = true; wifiAutoRetryBtn.textContent = '시도 중...';
      // read retry params from inputs
      const interval = (wifiRetryInterval && parseInt(wifiRetryInterval.value)) || 5;
      const attempts = (wifiRetryAttempts && parseInt(wifiRetryAttempts.value)) || 3;
      fetch(`/wifi/autoconnect?interval=${interval*1000}&attempts=${attempts}`)
        .then(r => r.json())
        .then(data => {
          if (data && data.success) {
            appendLog('system', 'Auto reconnect succeeded: ' + (data.ip || '')); 
            alert('자동 재연결 성공: ' + (data.ip || ''));
          } else {
            appendLog('error', 'Auto reconnect failed: ' + (data.error || ''));
            alert('자동 재연결 실패: ' + (data.error || '오류'));
          }
        })
        .catch(e => { appendLog('error', 'Auto reconnect error: ' + (e.message || e)); alert('자동 재연결 오류: ' + (e.message || e)); })
        .finally(()=>{ wifiAutoRetryBtn.disabled = false; wifiAutoRetryBtn.textContent = '자동 재연결 시도'; updateWiFiStatus(); });
    });
  }

  // Forget saved credentials button
  if (wifiForgetSavedBtn) {
    wifiForgetSavedBtn.addEventListener('click', () => {
      if(!confirm('저장된 크리덴셜을 삭제하시겠습니까?')) return;
      fetch('/wifi/disconnect?forget=1')
        .then(r => r.json())
        .then(()=>{ appendLog('system','Saved credentials removed'); updateWiFiStatus(); alert('저장된 크리덴셜이 삭제되었습니다.'); })
        .catch(e=>{ appendLog('error','Forget saved error: '+(e.message||e)); alert('삭제 실패'); });
    });
  }

  if (wifiDisconnectBtn) {
    wifiDisconnectBtn.addEventListener('click', () => {
      if (!confirm('WiFi 연결을 해제하시겠습니까?')) return;
      fetch('/wifi/disconnect')
        .then(r => r.json())
        .then(() => { appendLog('system', 'WiFi disconnected'); updateWiFiStatus(); })
        .catch(e => appendLog('error', 'Disconnect error: ' + (e.message || e)));
    });
  }

  // initial status
  // Load saved WiFi UI settings from device and apply to inputs
  fetch('/wifi/settings')
    .then(r => { if(!r.ok) throw new Error('No settings'); return r.json(); })
    .then(cfg => {
      try{
        if(cfg.interval_ms && wifiRetryInterval) wifiRetryInterval.value = Math.max(1, Math.round(cfg.interval_ms/1000));
        if(cfg.attempts && wifiRetryAttempts) wifiRetryAttempts.value = cfg.attempts;
        if(typeof cfg.save_default !== 'undefined' && wifiSaveCheckbox) wifiSaveCheckbox.checked = !!cfg.save_default;
      }catch(e){}
    }).catch(()=>{/* ignore */}).finally(()=>{ updateWiFiStatus(); });

  // Save WiFi settings to device Preferences
  function saveWifiSettings(){
    try{
      const intervalSec = (wifiRetryInterval && parseInt(wifiRetryInterval.value)) || 5;
      const attempts = (wifiRetryAttempts && parseInt(wifiRetryAttempts.value)) || 3;
      const saveDefault = (wifiSaveCheckbox && wifiSaveCheckbox.checked) ? '1' : '0';
      const params = new URLSearchParams();
      params.append('interval_ms', String(intervalSec * 1000));
      params.append('attempts', String(attempts));
      params.append('save_default', saveDefault);
      fetch('/wifi/settings', { method: 'POST', body: params })
        .then(r=>r.json())
        .then(j=>{ appendLog('system','Saved WiFi settings'); })
        .catch(e=>{ appendLog('error','Save WiFi settings failed: '+(e.message||e)); });
    }catch(e){ appendLog('error','saveWifiSettings error: '+(e.message||e)); }
  }

  if(wifiRetryInterval) wifiRetryInterval.addEventListener('change', saveWifiSettings);
  if(wifiRetryAttempts) wifiRetryAttempts.addEventListener('change', saveWifiSettings);
  if(wifiSaveCheckbox) wifiSaveCheckbox.addEventListener('change', saveWifiSettings);
});
</script>

</body>
</html>